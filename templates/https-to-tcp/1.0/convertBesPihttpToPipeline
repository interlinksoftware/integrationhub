#!/bin/bash
#
# ARG_OPTIONAL_SINGLE([channel],[c],[piHTTP Message channel to conver to a pipeline],[ALL])
# ARG_OPTIONAL_SINGLE([config_file],[f],[piHTTP config file to convert])
# ARG_OPTIONAL_SINGLE([destination_host],[d],[Destination host])
# ARG_OPTIONAL_SINGLE([destination_port],[p],[Destination port])
# ARG_HELP([The general script's help msg])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='cfdph'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_channel="ALL"
_arg_config_file=
_arg_destination_host=
_arg_destination_port=


print_help()
{
	printf '%s\n' "The general script's help msg"
	printf 'Usage: %s [-c|--channel <arg>] [-f|--config_file <arg>] [-d|--destination_host <arg>] [-p|--destination_port <arg>] [-h|--help]\n' "$0"
	printf '\t%s\n' "-c, --channel: piHTTP Message channel to conver to a pipeline (default: 'ALL')"
	printf '\t%s\n' "-f, --config_file: piHTTP config file to convert (no default)"
	printf '\t%s\n' "-d, --destination_host: Destination host (no default)"
	printf '\t%s\n' "-p, --destination_port: Destination port (no default)"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-c|--channel)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_channel="$2"
				shift
				;;
			--channel=*)
				_arg_channel="${_key##--channel=}"
				;;
			-c*)
				_arg_channel="${_key##-c}"
				;;
			-f|--config_file)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_config_file="$2"
				shift
				;;
			--config_file=*)
				_arg_config_file="${_key##--config_file=}"
				;;
			-f*)
				_arg_config_file="${_key##-f}"
				;;
			-d|--destination_host)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_destination_host="$2"
				shift
				;;
			--destination_host=*)
				_arg_destination_host="${_key##--destination_host=}"
				;;
			-d*)
				_arg_destination_host="${_key##-d}"
				;;
			-p|--destination_port)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_destination_port="$2"
				shift
				;;
			--destination_port=*)
				_arg_destination_port="${_key##--destination_port=}"
				;;
			-p*)
				_arg_destination_port="${_key##-p}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

format_key_regex="^format.[0-9]+.key"
format_value_regex="^format.[0-9]+.value"
tmpfile="/tmp/$(basename ${0}).$$"
script_dir="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
config_base=$(cd "${script_dir}" && pwd)

function is_bes_installed() {
    rpm -q iss-bes >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        return 0
    else
        return 1
    fi
}

function is_https_configured() {
    local config_file="${1}"
    local keystore_path
    local keystore_password

    keystore_path=$(grep -E "^http.sslKeystore" "${config_file}" | cut -d'=' -f2)
    keystore_password=$(grep -E "^http.sslKeystorePassword" "${config_file}" | cut -d'=' -f2)

    if [ ${#keystore_path} -gt 0 ] && [ ${#keystore_password} -gt 0 ]; then
        return 0
    else
        return 1
    fi
}

function validate_config_file() {
    local config_file="${1}"
    local port
    local keys
    local formats

    echo "Validating file '${config_file}'"

    port=$(grep -E "^http.listen.port" "${config_file}" | cut -d'=' -f2)
    keys=$(grep -E "${format_key_regex}" "${config_file}" | cut -d'=' -f2)
    formats=$(grep -E "${format_value_regex}" "${config_file}" | cut -d'=' -f2)

    if [ ${#port} -gt 0 ] && [ ${#keys} -gt 0 ] && [ ${#formats} -gt 0 ]; then
        return 0
    else
        return 1
    fi
}

function create_pipeline_file() {
    local file_to_convert="${1}"
    local channel_name
    local port
    local pipeline_file
    local json_config
    local check
    local array_check
    local template
    local ssl_context
    local ssl_keystore
    local ssl_password

    channel_name=$(basename "${file_to_convert}" | sed 's/\.[^.]*$//' )
    port=$(grep -E "^http.listen.port" "${file_to_convert}" | cut -d'=' -f2)
    apikey=$(grep -E "^http.apiKey " "${file_to_convert}" | cut -d'=' -f2)
    newlineReplacer=$(grep -E "^newline-replacement-characters" "${file_to_convert}" | cut -d'=' -f2 | sed -Ee 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    pipeline_file="${config_base}/${channel_name}.yml"

    if [ ! -f "${pipeline_file}" ]; then
        echo "Creating ${pipeline_file}"
        touch "${pipeline_file}"

        if is_https_configured "${file_to_convert}"; then
            template="https-to-tcp~1.0"
            protocol="https"
            ssl_context="sslContextParameters: \"#IssSslConfig\""
        else
            template="http-to-tcp~v1.0"
            protocol="http"
            ssl_context=""
        fi

        cat <<EOF >>"${pipeline_file}"
app:
  pipelines:
    "[${channel_name}-pipeline]":
      steps:
      - method: pipeline-template
        ref: "${template}"
        properties:
          hostname: 0.0.0.0
          protocol: "${protocol}"
          port: ${port}
          path: ""
          blankPlaceholder: "N/A"
          newlinePlaceholder: "${newlineReplacer:= }"
          apiKey: "${apikey}"
          ${ssl_context}
          logDropped: true
          logReceived: true
          logProcessed: true
          allowList:
            - "\${bodyAs(String)} regex '(?s)(.*?)'" # Allow everything
          denyList:
            - "\${bodyAs(String)} ~~ 'bad_event'"
          templates:
          destinationServers:
            - hostname: "${_arg_destination_host}"
              port: ${_arg_destination_port}
          preprocessHeaders:
            '[\${bodyAs(String)} regex "(?s)(.*?)"]':
              'ExampleHeader': "ExampleHeaderValue"
EOF

    else
        echo "Pipeline file already exists '${pipeline_file}'"
        exit 1
    fi

    if [ -f "${config_base}/application.yml" ]; then
        json_config=$(yq4 eval -o=j "${config_base}/application.yml")
        array_check=$(echo "${json_config}" | jq '.spring.config.import | length')

        if [ ${array_check} -ne 0 ]; then
            check=$(echo "${json_config}" | jq --arg channel "${config_base}/${channel_name}.yml" 'any(.spring.config.import[]; . == $channel)')
            if [ "${check}" = "false" ]; then
                json_config=$(echo "${json_config}" | jq --arg channel "${config_base}/${channel_name}.yml" '.spring.config.import += [$channel]')
            fi
        else
            json_config=$(echo "${json_config}" | jq --arg channel "${config_base}/${channel_name}.yml" '.spring.config.import += [$channel]')
        fi

        echo "${json_config}" | yq4 eval -P > "${config_base}/application.yml"
    fi

}

function add_format_template() {
    local channel_name="${1}"
    local key="${2}"
    local format="${3}"
    local split="${4}"
    local config_file="${config_base}/${channel_name}.yml"

    json_pipeline=$(yq4 eval -o=j "${config_file}" | jq --arg channel "[${channel_name}-pipeline]" --arg key "[\${bodyAs(String)} ~~ \"${key}\"]" --arg format "${format}" '.app.pipelines[$channel].steps[0].properties.templates[$key].format = $format')
    json_pipeline=$(echo "${json_pipeline}" | jq --arg channel "[${channel_name}-pipeline]" --arg key "[\${bodyAs(String)} ~~ \"${key}\"]" --arg split "${split}" '.app.pipelines[$channel].steps[0].properties.templates[$key].split = $split')
    echo "${json_pipeline}" | yq4 eval -P > "${config_file}"
}

function convert_formats() {
    local config_file="${1}"
    local channel_name
    local keys
    local key_format
    local key_value
    channel_name=$(basename "${config_file}" | sed 's/\.[^.]*$//' )
    pipeline_file="${config_base}/${channel_name}.yml"

    echo "Proccessing keys"
    keys=$(cat "${config_file}" | grep -E "${format_key_regex}" | cut -d '.' -f2)

    for key in ${keys}; do
        key_value=$(grep "format.${key}.key" "${config_file}" | cut -d '=' -f 2- | sed -Ee 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        key_format=$(grep "format.${key}.value" "${config_file}" | cut -d '=' -f 2- | sed -Ee 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        key_split=$(grep "format.${key}.split" "${config_file}" | cut -d '=' -f 2- | sed -Ee 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

        if [ ${#key_split} -eq 0 ]; then
            key_split="\${body}"
        else
            raw_key_split=$(echo "${key_split}" | sed -Ee 's/\$\.//')
            new_key_split=""

            IFS_ORIG=${IFS}
            export IFS="."
            for path in $raw_key_split; do
                new_key_split="${new_key_split}[${path}]"
            done
            export IFS=${IFS_ORIG}

            key_split="\${body${new_key_split}}"
        fi

        echo "Proccessing key '${key}'"

        for map in $(echo "${key_format}" | perl -ne 'print "$_\n" for /\[((?:[^][]+|(?R))*+)\]/g'); do
            new_map=$(echo "${map}" | sed -e 's/^\/root\///' -e 's/\//\\\./g' -e 's/\[/\\\./' -e 's/\]//')
            if [[ ${new_map:0:2} == "\." ]]; then
                new_map="${new_map:2}"
            fi

            map=$(echo "${map}" | sed -e 's/\//\\\//g' -e 's/\[/\\\[/g' -e 's/\]/\\\]/g')
            key_format=$(echo "${key_format}" | sed -e "s/${map}/${new_map}/g")
        done

        key_format=$(echo "${key_format}" | sed -e "s/\[/\${sanitize(body\./g" -e "s/\]/!\'N\/A\')}/g")
        add_format_template "${channel_name}" "${key_value}" "${key_format}" "${key_split}"
    done
}

function handle_config_file() {
    local config_file="${1}"

    for file in ${config_file//,/ }; do
        if [ -f "${file}" ]; then
            echo "Parsing file '${file}'"
            if validate_config_file "${file}"; then
                echo "Converting file to pipeline"
                create_pipeline_file "${file}"
                convert_formats "${file}"
            else
                echo "Invalid file"
            fi
        else
            echo "File '${file}' does not exist"
        fi
    done
}

function handle_channel_arg() {
    local channel_list
    local query="select s_mcname from iss_pp_mcdef_table where s_mc IN (select s_mc from iss_pp_mccomp_table where s_comp = (select s_comp from iss_pp_comptypes_table where s_pgm = 'piHTTP'))"
    channel_list=$(echo "${_arg_channel}" | sed -E "1 { s/^'?/'/; s/'?,'?/','/g; s/'?$/'/ }")

    if is_bes_installed; then
        if ! echo "${_arg_channel}" | grep -q -i "ALL"; then
            query="${query} AND s_mcname IN (${channel_list})"
        fi

        DBcmd "${query};" >"${tmpfile}" 2>&1
        if [ $? -ne 0 ]; then
            echo "Failed to get list of piHTTP channels"
            cat "${tmpfile}" && rm -f "${tmpfile}"
        fi

        for channel in $(cat "${tmpfile}" | head -n -2 | tail -n +3); do
            handle_config_file "/opt/ISS/POWERpack/cfg/${channel}.cfg"
        done
    else
        echo "BES is not installed!"
        exit 1
    fi
}

function handle_destination_host() {
    if [ ${#_arg_destination_host} -eq 0 ]; then
        printf "\nEnter the destination hostname: "
        read _arg_destination_host
    fi
}

function handle_destination_port() {
    if [ ${#_arg_destination_port} -eq 0 ]; then
        printf "\nEnter the destination port: "
        read _arg_destination_port
    fi
}

function check_for_required_commands() {
    if ! command -v "yq4" &>/dev/null; then
        echo "command 'yq4' does not exist!"
        exit 255
    else
        if [ ! $(yq4 -V | cut -d" " -f4 | cut -d"." -f2) -ge 4 ] && [ ! $(yq4 -V | cut -d" " -f4 | cut -d"." -f2) -ge 16 ]; then
            echo "Incompatible version of yq4 found"
            exit 255
        fi
    fi

    if ! command -v "jq" &>/dev/null; then
        echo "command 'jq' does not exist!"
        exit 255
    fi
}

function main() {
    check_for_required_commands
    handle_destination_host
    handle_destination_port

    if [ ${#_arg_config_file} -ne 0 ]; then
        echo "_arg_config_file = ${_arg_config_file}"
        handle_config_file "${_arg_config_file}"
    else
        echo "_arg_channel = ${_arg_channel}"
        handle_channel_arg
    fi

}

main
