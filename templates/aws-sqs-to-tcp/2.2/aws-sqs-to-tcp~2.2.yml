shared:
    templates:
      "[aws-sqs-to-tcp~2.2]":
        version: 2.2
        minimumCompatibilityVersion: 2.3.0
        description: "The aws-sqs-to-tcp template provides functionality to transfer, filter/transform and send from an AWS SQS message queue to a TCP listener, via an integration-hub pipeline."
        placeholders:
          "queueNameOrArn":
            description: "The Amazon Resource Name or Queue Name"
            bind-to-exchange: true
            required: true

          "schedule":
            description: "The cron expression that defines the execution schedule for this pipeline"
            required: false
            defaultValue: "0 0/1 * * * ?"
            type: "string"

          "defaultCredentials":
            description: "Use credentials from AWS instance"
            required: false
            defaultValue: false
            type: "boolean"

          "accessKey":
            description: "The Amazon AWS Access Key"
            required: false
            defaultValue: false
            type: "string"

          "secretKey":
            description: "The Amazon AWS Secret Key"
            required: false
            defaultValue: false
            type: "string"

          "proxyHost":
            description: "The proxy hostname, if using a proxy"
            required: false
            type: "string"
            defaultValue: ""

          "proxyPort":
            description: "The proxy port, if using a proxy"
            required: false
            type: "integer"
            defaultValue: 1234

          "proxyProtocol":
            description: "The proxy protcol, if using a proxy"
            required: false
            type: "string"
            defaultValue: "HTTPS"

          "destinationServers":
            description: "List of servers to send the pipeline output to"
            bind-to-exchange: true
            required: true
            type: "array"
  
          "blankPlaceholder":
            description: "String to replace blank values with"
            required: false
            defaultValue: "N/A"

          "fieldLimit":
            description: "The maximum number of characters allowed in each field of the incoming message"
            required: false
            defaultValue: 256
            type: "integer"

          "messageLimit":
            description: "The maximum number of characters allowed in the message after it has been formatted"
            required: false
            defaultValue: 4096
            type: "integer"
  
          "allowList":
            bind-to-exchange: true
            description: "List of logic statements to determine if the request can proceed"
            required: false
            defaultValue: "NOT_SET"
  
          "denyList":
            bind-to-exchange: true
            description: "List of logic statements to halt the request"
            required: false
            defaultValue: "NOT_SET"
  
          "filters":
            bind-to-exchange: true
            description: "List of filters to match and format the data"
            required: false
            defaultValue: "NOT_SET"
  
          "logProcessed":
            description: "To log the data once processed into its final form, set this to true. The received file is logs/<pipeline name>-<yyyymmdd>.processed"
            bind-to-exchange: true
            required: false
            type: "boolean"
            defaultValue: true
  
          "logSuccess":
            description: "To log messages that were successfully sent to the tcp destination, set this to true. The success file is logs/<pipeline name>-<yyyymmdd>.success"
            bind-to-exchange: true
            required: false
            type: "boolean"
            defaultValue: true
  
          "logReceived":
            description: "To log all received data, set this to true. The received file is logs/<pipeline name>-<yyyymmdd>.received"
            bind-to-exchange: true
            required: false
            type: "boolean"
            defaultValue: true
  
          "logDropped":
            description: "To log all dropped data, set this to true. The dropped file is logs/<pipeline name>-<yyyymmdd>.dropped"
            bind-to-exchange: true
            required: false
            type: "boolean"
            defaultValue: true
  
          "logFailed":
            description: "To log all failed data, set this to true. The failed file is logs/<pipeline name>-<yyyymmdd>.failed"
            bind-to-exchange: true
            required: false
            type: "boolean"
            defaultValue: true
  
          "newlinePlaceholder":
            description: "String to replace newline characters values with"
            required: false
            defaultValue: " "
  
          "preprocessHeaders":
            description: ""
            required: false
            defaultValue: "NOT_SET"
            bind-to-exchange: true
  
          "uiMessageLimit":
            description: "Limit of failed/dropped/success/processed/received messages to display on the UI."
            required: false
            defaultValue: "200"
  
        uiSchema:
          type: object
          properties:
            awsConnection:
              type: object
              title: AWS Connection
              ui:
                component: group
                icon: info-circle
              properties:
                config:
                  type: grid
                  ui:
                    columns:
                      - 25%
                      - auto
                    alignRow: baseline
                  properties:
                    awsConnectionTitle:
                      type: grid
                      ui:
                        columns:
                          - auto
                          - 1fr
                        areas:
                          - description-text description-help
                        alignRow: center
                      properties:
                        description-text:
                          type: typography
                          defaultValue: Endpoint
                          ui:
                            indexed: true
                        description-help:
                          type: typography
                          ui:
                            icon: info-circle
                          help:
                            icon: info-circle
                            content: |-
                              ### AWS Connection Properties

                                The following properties can be specified for this data collector.

                                | property | description |
                                | -- | -- |
                                | Queue Name of ARN | Name of the queue in AWS SQS or the Amazon Resource Name (ARN) for the SQS environment |
                                | Access Key | The Amazon AWS Access Key |
                                | Secret Key | The Amazon AWS Secret Key |
                    awsConnectionValue:
                      type: object
                      properties:
                        main:
                          type: grid
                          ui:
                            areas:
                              - queueNameOrArn queueNameOrArn queueNameOrArn queueNameOrArn
                              - accessKey accessKey secretKey secretKey
                              - authentication authentication authentication authentication
                            alignRow: baseline
                          properties:
                            queueNameOrArn:
                              type: string
                              title: Queue Name or ARN
                              validation:
                                required: true
                                message: Please enter a queue name or ARN
                            accessKey:
                              type: string
                              title: Access Key
                            secretKey:
                              type: password
                              title: Secret Key
                        proxyConfig:
                          type: expansion-panel
                          title: Proxy Configuration (Optional)
                          ui:
                            elevation: 2
                          properties:
                            authenticationGrid:
                              type: grid
                              ui:
                                areas:
                                  - proxyProtocol proxyHost proxyHost proxyPort
                                alignRow: baseline
                              properties:
                                proxyProtocol:
                                  type: select
                                  title: Proxy Protocol
                                  ui:
                                    options:
                                      - HTTP
                                      - HTTPS
                                  defaultValue: HTTPS
                                proxyHost:
                                  type: string
                                  title: Proxy Host
                                proxyPort:
                                  type: number
                                  title: Proxy Port
            destinationSection:
              type: object
              properties:
                destinationHeader:
                  type: header
                  title: Destination
                destinationContainer:
                  type: object
                  ui:
                    component: group
                  properties:
                    commandConfig:
                      type: grid
                      ui:
                        columns:
                          - 25%
                          - auto
                        alignRow: baseline
                      properties:
                        destinationTitle:
                          type: grid
                          ui:
                            columns:
                              - auto
                              - 1fr
                            areas:
                              - description-text description-help
                            alignRow: center
                          properties:
                            description-text:
                              type: typography
                              defaultValue: Destination
                              ui:
                                indexed: true
                            description-help:
                              type: typography
                              ui:
                                icon: info-circle
                              help:
                                icon: info-circle
                                content: |-
                                  ### Destination Properties

                                    The following properties can be specified for the destination.

                                    | property | description |
                                    | -- | -- |
                                    | hostname | The hostname or IP address of the TCP listener this pipeline will forward messages to |
                                    | port | The port that the TCP channel is listening on |
                        destinationValue:
                          type: object
                          properties:
                            destinationGrid:
                              type: grid
                              ui:
                                columns:
                                  - auto
                              properties:
                                destinationServers:
                                  type: array
                                  title: destination servers to forward messages to
                                  ui:
                                    columns:
                                      - auto
                                      - auto
                                  validation:
                                    message: "Please define one destination host"
                                    required: true
                                  propertyTemplate:
                                    hostname:
                                      type: string
                                      title: hostname
                                      validation:
                                        message: "Please specify a valid hostname"
                                        required: true
                                    port:
                                      type: number
                                      title: port
                                      validation:
                                        regex: ^[0-9]+$
                                        message: specify port number >1024
            optionalSettings:
              type: expansion-panel
              title: Optional Settings
              ui:
                elevation: 2
              properties:
                togglePreprocessHeaders:
                  type: switch
                  title: Configure Pre-process Headers
                  defaultValue: false
                conditional-section-preprocessHeaders:
                  type: conditional
                  expression:
                    left: $togglePreprocessHeaders
                    operator: "=="
                    right: true
                  properties:
                    preprocessHeaders:
                      type: array
                      title: Pre-processing Headers Override
                      ui:
                        columns:
                          - auto
                          - auto
                      propertyTemplate:
                        expression:
                          type: text
                          title: The expression to match
                          help:
                            icon: info-circle
                            content: |-
                              ### Simple Expressions

                              > **field** _operator_ **value**

                              ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                              ##### value: the value being tested against
                              ##### operators

                                  ==          equals
                                  =~          equals (case insensitive)
                                  !=          does not equal
                                  !=~         does not equal (case insensitive)
                                  contains    contains string
                                  !contains   does not contain
                                  regex       matches regex expression
                                  !regex      does not match regex expression
                                  &&          AND multiple expressions
                                  ||          OR multiple expressions

                              ##### See examples below

                                  # match any string
                                  ${bodyAs(String)} regex '(?s)(.*?)'
                                  # incoming message contains 'this' but not 'that'
                                  ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                                  # incoming message contains 'dog' or 'cat'
                                  ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                                  # incoming message field 'username' equals 'ppadmin'
                                  ${body.username} == 'ppadmin'
                                  # incoming message field 'username' is not null
                                  ${body.username} != null
                                  # incoming message field 'origindate' equals todays date
                                  ${body.origindate} == ${date:now:yyyyMMdd}
                        headers:
                          type: map
                          title: Headers
                          ui:
                            keyPlaceholder: Header Name
                          valueSchema:
                            type: text
                            ui:
                              placeholder: Header Value
                toggleAllowDenyList:
                  type: switch
                  title: Configure Allow/Deny List
                  defaultValue: false
                conditional-section-allow-deny:
                  type: conditional
                  expression:
                    left: $toggleAllowDenyList
                    operator: "=="
                    right: true
                  properties:
                    allowList:
                      type: array
                      title: Allow list (process if expression is matched)
                      ui:
                        indexed: true
                      help:
                        icon: info-circle
                        content: |-
                          ### Simple Expressions

                          > **field** _operator_ **value**

                          ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                          ##### value: the value being tested against
                          ##### operators

                              ==          equals
                              =~          equals (case insensitive)
                              !=          does not equal
                              !=~         does not equal (case insensitive)
                              contains    contains string
                              !contains   does not contain
                              regex       matches regex expression
                              !regex      does not match regex expression
                              &&          AND multiple expressions
                              ||          OR multiple expressions

                          ##### See examples below

                              # match any string
                              ${bodyAs(String)} regex '(?s)(.*?)'
                              # incoming message contains 'this' but not 'that'
                              ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                              # incoming message contains 'dog' or 'cat'
                              ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                              # incoming message field 'username' equals 'ppadmin'
                              ${body.username} == 'ppadmin'
                              # incoming message field 'username' is not null
                              ${body.username} != null
                              # incoming message field 'origindate' equals todays date
                              ${body.origindate} == ${date:now:yyyyMMdd}
                    denyList:
                      type: array
                      title: Deny list (drop if expression is matched)
                      ui:
                        indexed: true
                      help:
                        icon: info-circle
                        content: |-
                          ### Simple Expressions

                          > **field** _operator_ **value**

                          ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                          ##### value: the value being tested against
                          ##### operators

                              ==          equals
                              =~          equals (case insensitive)
                              !=          does not equal
                              !=~         does not equal (case insensitive)
                              contains    contains string
                              !contains   does not contain
                              regex       matches regex expression
                              !regex      does not match regex expression
                              &&          AND multiple expressions
                              ||          OR multiple expressions

                          ##### See examples below

                              # match any string
                              ${bodyAs(String)} regex '(?s)(.*?)'
                              # incoming message contains 'this' but not 'that'
                              ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                              # incoming message contains 'dog' or 'cat'
                              ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                              # incoming message field 'username' equals 'ppadmin'
                              ${body.username} == 'ppadmin'
                              # incoming message field 'username' is not null
                              ${body.username} != null
                              # incoming message field 'origindate' equals todays date
                              ${body.origindate} == ${date:now:yyyyMMdd}
                toggleFilter:
                  type: switch
                  title: Configure Filters & Alert Formatting
                  defaultValue: false
                conditional-section-filters:
                  type: conditional
                  expression:
                    left: $toggleFilter
                    operator: '=='
                    right: true
                  properties:
                    filters:
                      type: array
                      title: filter and format messages
                      ui:
                        columns:
                          - 30%
                          - auto
                      propertyTemplate:
                        expression:
                          type: string
                          title: Expression
                          description: 'Simple Expression (ie: ${bodyAs(String)} contains ''EVENT'')'
                          help:
                            icon: info-circle
                            content: |-
                              ### Simple Expressions

                              > **field** _operator_ **value**

                              ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                              ##### value: the value being tested against
                              ##### operators

                                  ==          equals
                                  =~          equals (case insensitive)
                                  !=          does not equal
                                  !=~         does not equal (case insensitive)
                                  contains    contains string
                                  !contains   does not contain
                                  regex       matches regex expression
                                  !regex      does not match regex expression
                                  &&          AND multiple expressions
                                  ||          OR multiple expressions

                              ##### See examples below

                                  # match any string
                                  ${bodyAs(String)} regex '(?s)(.*?)'
                                  # incoming message contains 'this' but not 'that'
                                  ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                                  # incoming message contains 'dog' or 'cat'
                                  ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                                  # incoming message field 'username' equals 'ppadmin'
                                  ${body.username} == 'ppadmin'
                                  # incoming message field 'username' is not null
                                  ${body.username} != null
                                  # incoming message field 'origindate' equals todays date
                                  ${body.origindate} == ${date:now:yyyyMMdd}
                        format:
                          type: string
                          title: Format
                          description: 'Target Format (ie: AUTO | ${auto}'
                          help:
                            icon: info-circle
                            content: |-
                              # Transform Format
                              The format output redefines how you wish to transform the message.

                              ## JSON Object example
                              incoming message

                                  {
                                    "user": {
                                      "name": "ppadmin",
                                      "uid": 229,
                                      "group": "ppusers"
                                    },
                                    "origindate": "2022-12-15 12:01:34"
                                  }

                              ### auto mapping
                              Auto transform format

                                  UserAlert ${auto}

                              Transformed output

                                  UserAlert datetime = 2022-12-15 12:01:34 | name = ppadmin | group = ppusers | Accept = text/plain, application/xml, text/xml, application/json, application/*+xml, application/*+json, */* |  Accept-Encoding = gzip,deflate |  Connection = keep-alive |  Content-Length = 114 |  Content-Type = application/json |  correlationId = 43CA053BE23B183-0000000000000002 |  Host = localhost:30052 |  HttpCharacterEncoding = UTF-8 |  HttpMethod = POST |  HttpPath = N/A |  HttpQuery = null |  HttpUri = / |  HttpUrl = [http://localhost:30052/](http://localhost:30052/) |  parentId = 43CA053BE23B183-0000000000000001 |  ServletContextPath = / |  User-Agent = Apache-HttpClient/4.5.13 (Java/1.8.0_241) |

                              ### pre-defined mapping

                              Pre-defined transform format
                                  UserAlert datetime = ${body.origindate} | name = ${body.user.name} | group = ${body.user.group} |

                              Transformed output

                                  UserAlert datetime = 2022-12-15 12:01:34 | name = ppadmin | group = ppusers |

                              ## JSON Array example
                              incoming message

                                  {
                                    "testfield": "VALUE1",
                                    "testfield2": "VALUE2",
                                    "nested": {
                                      "nestedField": "hello",
                                    },
                                    "array": [
                                      "array1",
                                      "array2",
                                      "array3"
                                    ]
                                  }

                              ### auto mapping
                              Auto transform format

                                  UserAlert ${auto}

                              Transformed output

                                  UserAlert array.0 = array1 |  array.1 = array2 |  array.2 = array3 |  testfield2 = VALUE2 |   nested.nestedField = hello |  testfield = VALUE1 |   Accept = text/plain, application/xml, text/xml, application/json, application/*+xml, application/*+json, */* |  Accept-Encoding = gzip,deflate |  Connection = keep-alive |  Content-Length = 114 |  Content-Type = application/json |  correlationId = 43CA053BE23B183-0000000000000002 |  Host = localhost:30052 |  HttpCharacterEncoding = UTF-8 |  HttpMethod = POST |  HttpPath = N/A |  HttpQuery = null |  HttpUri = / |  HttpUrl = [http://localhost:30052/](http://localhost:30052/) |  parentId = 43CA053BE23B183-0000000000000001 |  ServletContextPath = / |  User-Agent = Apache-HttpClient/4.5.13 (Java/1.8.0_241) |

                              ### pre-defined mapping

                              Pre-defined transform format

                                  UserAlert firstOne = ${body.array[0]} | msg = ${body.nested.nestedField} |
                              Transformed output

                                  UserAlert firstOne = array1 | msg = hello |
                        split:
                          type: string
                          title: Split
                          defaultValue: ${body}
                          help:
                            icon: info-circle
                            content: |-
                              # Split expression
                              The split expression allows you to produce multiple messages from a single payload containing an array.
                              By default it will split the main body of the message.

                              ## JSON Array example
                              By default it will split the payload if it is an array.
                              For example:

                                  [
                                    {
                                      "user": {
                                        "name": "ppadmin",
                                        "uid": 229,
                                        "group": "ppusers"
                                      },
                                      "origindate": "2022-12-15 12:01:34"
                                    },
                                    {
                                      "user": {
                                        "name": "Jeff",
                                        "uid": 456,
                                        "group": "ppusers"
                                      },
                                      "origindate": "2022-12-15 15:56:27"
                                    }
                                  ]

                              Will result in two messages being sent to the destination.

                              ### Specifying the split expression
                              If you wish to split over a nested array, you can define the path to the "array".
                              With an incoming message of:

                                  {
                                    "data": [
                                      {
                                        "user": {
                                          "name": "ppadmin",
                                          "uid": 229,
                                          "group": "ppusers"
                                        },
                                        "origindate": "2022-12-15 12:01:34"
                                      },
                                      {
                                        "user": {
                                          "name": "Jeff",
                                          "uid": 456,
                                          "group": "ppusers"
                                        },
                                        "origindate": "2022-12-15 15:56:27"
                                      }
                                    ]
                                  }

                              The split expression will be:
                                  ${body.data}
                    alertFormat:
                      type: grid
                      ui:
                        columns:
                          - 30%
                          - 30%
                          - 20%
                          - auto
                      properties:
                        newlinePlaceholder:
                          type: string
                          title: Newline Placeholder
                          description: Replace newline characters with this value, defaults to a single space
                        blankPlaceholder:
                          type: string
                          title: Blank Placeholder
                          description: Replace blank keys with this value, defaults to a 'N/A'
                          defaultValue: "N/A"
                        fieldLimit:
                          type: string
                          title: Field Limit
                          defaultValue: 256
                        messageLimit:
                          type: string
                          title: Message Limit
                          defaultValue: 4096
                toggleLogs:
                  type: switch
                  title: Configure Logging
                  defaultValue: false
                conditional-section-logs:
                  type: conditional
                  expression:
                    left: $toggleLogs
                    operator: '=='
                    right: true
                  properties:
                    uiMessageLimit:
                      type: number
                      title: UI Message Limit
                      defaultValue: 200
                      description: >-
                        Limit of failed/dropped/success/processed/received messages to
                        display on the UI
                    logOptions:
                      type: grid
                      ui:
                        columns:
                          - auto
                          - auto
                          - auto
                          - auto
                          - auto
                        alignRow: baseline
                      properties:
                        logReceived:
                          defaultValue: true
                          type: checkbox
                          title: log messages received
                        logDropped:
                          defaultValue: true
                          type: checkbox
                          title: log dropped messages
                        logProcessed:
                          type: checkbox
                          title: log processed messages
                          defaultValue: true
                        logSuccess:
                          defaultValue: true
                          type: checkbox
                          title: log success messages
                        logFailed:
                          defaultValue: true
                          type: checkbox
                          title: log failed messages

        pipelineFlow:
          - type: block
            label: Amazon Web Servers SQS
            icon: messages
          - type: arrow
            forward: true
            pullForward: true
          - type: pipe
            children:
              - type: arrow
                forward: true
                pullForward: true
              - type: block
                label: drop
                icon: trash-can
              - type: arrow
                forward: true
              - type: block
                label: filter
                icon: filter
              - type: arrow
                forward: true
              - type: block
                label: transform
                icon: shuffle
              - type: arrow
                forward: true
                pullForward: true
          - type: block
            label: "Forward to TCP Socket(s)"
            icon: arrow-down-to-square
  
        exceptions:
          # REF-AOD - Catch data conversion exceptions
          - catches:
              - "com.fasterxml.jackson.core.JsonParseException"
              - "com.fasterxml.jackson.core.io.JsonEOFException"
              - "org.yaml.snakeyaml.parser.ParserException"
            handled:
              type: constant
              expression: "true"
            use-original-message: true
            steps:
              # REF-OCY - Log the error
              - method: log
                level: ERROR
                message: "Error parsing body: ${body}. Caused by: ${exception.message}"
              # REF-GXV - Set header "Integration_HubHttpResponseCode" to 400
              - method: setHeader
                key: Integration_HubHttpResponseCode
                value:
                  type: constant
                  expression: 400
              # REF-1SL - Set header "Content-Type" to "text/plain"
              - method: setHeader
                key: Content-Type
                value:
                  type: constant
                  expression: application/json
              # REF-FG2 - Set body to message
              - method: setBody
                expression:
                  type: simple
                  expression: '{"status": "ERROR", "requestId": "${exchangeId}", "message": "Error parsing the body.\nPlease check message channel logs for more details." }'
              - method: isslog
                message: "parentId=${exchange.properties[parentId]} | failed() | Error processing the body, please check the logs for more details. Exception=${exception.message}"
                type: failed
                queueSize: $[[uiMessageLimit]]
                writeToFile: $[[logFailed]]
                writeToDatabase: $[[logFailed]]
              - method: stop
  
          # REF-EJC - Catch genric exception
          - catches:
              - "java.lang.Exception"
            handled:
              type: constant
              expression: true
            steps:
              # REF- - Log the error
              - method: log
                level: ERROR
                message: "Error processing data: ${exception}"
              # REF-ONW - Set header "Integration_HubHttpResponseCode" to 400
              - method: setHeader
                key: Integration_HubHttpResponseCode
                value:
                  type: constant
                  expression: 400
              - method: setHeader
                key: Content-Type
                value:
                  type: constant
                  expression: application/json
              # REF-31X - Set body to error message
              - method: setBody
                expression:
                  type: simple
                  expression: '{"status": "ERROR", "requestId": "${exchangeId}", "message": "Error processing the body.\nPlease check message channel logs for more details." }'
              - method: isslog
                message: "parentId=${exchange.properties[parentId]} | failed() | Error processing the body, please check the logs for more details. Exception=${exception.message}"
                type: failed
                queueSize: $[[uiMessageLimit]]
                writeToFile: $[[logFailed]]
                writeToDatabase: $[[logFailed]] 
              - method: stop
  
          # REF-M0L - Catch No payload
          - catches:
              - "org.apache.integration_hub.NoTypeConversionAvailableException"
              - "com.fasterxml.jackson.databind.exc.MismatchedInputException"
            handled:
              type: constant
              expression: true
            steps:
              # REF- - Log the error
              - method: log
                level: ERROR
                message: "No content in the payload: ${exception}"
              # REF-PO0 - Set header "Integration_HubHttpResponseCode" to 400
              - method: setHeader
                key: Integration_HubHttpResponseCode
                value:
                  type: constant
                  expression: 400
              - method: setHeader
                key: Content-Type
                value:
                  type: constant
                  expression: application/json
              # REF-31X - Set body to error message
              - method: setBody
                expression:
                  type: simple
                  expression: '{"status": "ERROR", "requestId": "${exchangeId}", "message": "Error no content in the body" }'
              - method: isslog
                message: "parentId=${exchange.properties[parentId]} | failed() | Error processing the body, please check the logs for more details. Exception=${exception.message}"
                type: failed
                queueSize: $[[uiMessageLimit]]
                writeToFile: $[[logFailed]]
                writeToDatabase: $[[logFailed]]
              - method: stop
  
          # REF-XAG - Failed to send on socket
          - catches:
              - "java.net.ConnectException"
            handled:
              type: constant
              expression: true
            steps:
              # REF- - Log the error
              - method: log
                level: "ERROR"
                message: "Failed to send body to ${exchangeProperty.destinationHost}"
              - method: choice
                when:
                  - predicate:
                      type: simple
                      expression: "${exchangeProperty.placeholders[logFailed]} != null && ${exchangeProperty.placeholders[logFailed]} == true"
                    steps:
                      # REF-4KD - Write log message to "failed" file
                      - method: isslog
                        message: "parentId=${exchange.properties[parentId]} | failed(${exchange.properties['filterExpression']}) | [dest=${exchangeProperty.destinationHost}, message=${exchange.properties['internalProcessedMessage']}]"
                        type: failed
                        queueSize: $[[uiMessageLimit]]
                        writeToFile: $[[logFailed]]
                        writeToDatabase: $[[logFailed]]
              - method: stop
  
        steps:
          # REF-36J - HTTP Listener
          - method: from
            component: aws2-sqs
            properties:
              queueNameOrArn: "$[[queueNameOrArn]]"
              useDefaultCredentialsProvider: $[[defaultCredentials]]
              accessKey: $[[accessKey]]
              secretKey: $[[secretKey]]
              proxyHost: $[[proxyHost]]
              proxyPort: $[[proxyPort]]
              proxyProtocol: $[[proxyProtocol]]
              runLoggingLevel: "INFO"
  
          # REF-B9G - Store incoming message as "internalOrigMsg" property
          - method: setProperty
            key: internalOrigMsg
            value:
              type: "simple"
              expression: "${body}"
  
          # REF- - Set header "requestId" to the initial "parent" correlationId
          - method: setProperty
            key: parentId
            value:
              type: "simple"
              expression: "${exchangeId}"
  
          # REF- - Store headers in exchange
          - method: process
            classname: com.interlinksoftware.integrationhub.config.step.processor.HeadersToPropertyProcessor
  
          # REF-L14 - IF logReceived is enabled
          - method: choice
            when:
              - predicate:
                  type: simple
                  expression: "${exchangeProperty.placeholders[logReceived]} != null && ${exchangeProperty.placeholders[logReceived]} == true"
                steps:
                  # REF- - Debug message
                  - method: log
                    level: "DEBUG"
                    message: "Writing body to received file"
  
                  # REF-H9Z - Log message to file
                  - method: isslog
                    message: "received | ${bodyAs(String)}"
                    type: received
                    queueSize: $[[uiMessageLimit]]
                    writeToFile: $[[logReceived]]
                    writeToDatabase: $[[logReceived]]
  
          # REF- - Set body to origin message
          - method: setBody
            expression:
              type: simple
              expression: "${exchangeProperty.internalOrigMsg}"
  
          - method: choice
            when:
              - predicate:
                  type: simple
                  expression: "${exchangeProperty.placeholders[preprocessHeaders]} != null && ${exchangeProperty.placeholders[preprocessHeaders]} != 'NOT_SET' && ${exchangeProperty.placeholders[preprocessHeaders]} is 'java.util.List' && ${exchangeProperty.placeholders[preprocessHeaders].size()} > 0"
                steps:
                  - method: loop
                    expression:
                      type: simple
                      expression: "${exchangeProperty.placeholders[preprocessHeaders].size()}"
                    copy: false
                    steps:
                      - method: choice
                        when:
                          - predicate:
                              type: simple
                              expression: "${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex}).getOrDefault(expression, NOT_SET)} != 'NOT_SET'"
                            steps:
                              - method: setProperty
                                key: preprocessHeaderExpression
                                value:
                                  type: "simple"
                                  expression: "${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex})[expression]}"
                              - method: choice
                                when:
                                  - predicate:
                                      type: simple
                                      expression: "${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex}).getOrDefault(headers, NOT_SET)} != 'NOT_SET' && ${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex})[headers]} is 'java.util.Map'"
                                    steps:
                                      - method: choice
                                        when:
                                          - predicate:
                                              type: groovy
                                              expression: |
                                                preprocessHeaderExpression = exchange.properties.get("preprocessHeaderExpression")
                                                language = exchange.getContext().resolveLanguage("simple")
                                                predicate = language.createPredicate(preprocessHeaderExpression)
                                                return predicate.matches(exchange);
                                            steps:
                                              - method: log
                                                level: "DEBUG"
                                                message: "Preprocess header expression(${exchangeProperty.preprocessHeaderExpression}) matches!!"
                                              - method: setBody
                                                expression:
                                                  type: simple
                                                  expression: "${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex})[headers]}"
                                              - method: process
                                                classname: com.interlinksoftware.integrationhub.config.step.processor.BodyToHeadersProcessor
                                        otherwise:
                                          - method: log
                                            level: "DEBUG"
                                            message: "Preprocess header expression(${exchangeProperty.preprocessHeaderExpression}) does not match"
                                otherwise:
                                  - method: log
                                    level: "ERROR"
                                    message: "No headers for expression(exchangeProperty.preprocessHeaderExpression) in preprocessor definition '(${header.Integration_HubLoopIndex})'"
                        otherwise:
                          - method: log
                            level: "ERROR"
                            message: "No expression in preprocessor definition '${header.Integration_HubLoopIndex}'"
            otherwise:
              - method: log
                level: "DEBUG"
                message: "No preprocessor definitions"
  
          # REF- - Set body to origin message
          - method: setBody
            expression:
              type: simple
              expression: "${exchangeProperty.internalOrigMsg}"
  
          # REF-4IZ - Data decoding
          - method: choice
            when:
              # REF-BEK
              - predicate:
                  type: simple
                  expression: "${header.Content-Encoding} in 'gzip,application/gzip'"
                steps:
                  # REF- - Debug message
                  - method: log
                    level: "DEBUG"
                    message: "decoding from gzip"
                  - method: unmarshal
                    type: gzip
  
          # REF-1CY -  Datatype decoding
          - method: choice
            when:
              # REF-0KL - Unmarshal JSON
              - predicate:
                  type: simple
                  expression: "${header.Content-Type} ~~ 'json'"
                steps:
                  # REF- - Debug message
                  - method: log
                    level: "DEBUG"
                    message: "decoding from json"
                  - method: unmarshal
                    type: json
                  - method: choice
                    when:
                      - predicate:
                          type: simple
                          expression: "${body.getClass().getName()} == 'java.lang.String'"
                        steps:
                          - method: log
                            level: "DEBUG"
                            message: "decoding from json string - ${body.getClass().getName()}"
                          - method: unmarshal
                            type: json
                  # Cache the unmarshalled body
                  - method: setProperty
                    key: unmarshalledBody
                    value:
                      type: "simple"
                      expression: "${body}"
                  # Append correlationId into the body
                  - method: setBody
                    expression:
                      type: "groovy"
                      expression: |
                        if (body instanceof Map) {
                          body["correlationId"] = exchange.properties["parentId"]
                        }

                        if (body instanceof ArrayList) {
                          body.eachWithIndex { it, i ->
                            if (it instanceof Map) {
                              body[i]["correlationId"] = exchange.properties["parentId"]
                            }
                          }
                        }

                        return body
                  # Convert the body back to its orig type
                  - method: marshal
                    type: json
                  # Cache this body for use later on in the template
                  - method: setProperty
                    key: rawBody
                    value:
                      type: "simple"
                      expression: "${bodyAs(String)}"
              # REF-FU6 - Unmarshal XML
              - predicate:
                  type: simple

