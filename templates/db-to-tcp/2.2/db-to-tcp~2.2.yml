shared:
  templates:
    "[db-to-tcp~2.2]":
      version: 2.2
      minimumCompatibilityVersion: 2.4.0
      description: "The db-to-tcp template provides functionality to transfer, filter/transform and send data from databases using JDBC to a TCP listener, via an integration-hub pipeline."
      placeholders:
        "sql":
          description: "Array of SQL statements"
          bind-to-exchange: true
          required: true
          type: "array"
        "destinationServers":
          description: "List of servers to send the pipeline output to"
          bind-to-exchange: true
          required: true
          type: "array"
        "cronSchedule":
          description: "The cron expression that defines the execution schedule for this pipeline"
          required: false
          defaultValue: "0 * * ? * *"
          type: "string"
        "dataSourceName":
          description: "The data source name to use for the pipeline input"
          required: true
          type: "string"
        "blankPlaceholder":
          description: "String to replace blank values with"
          required: false
          defaultValue: "N/A"
          type: "string"
        "newlinePlaceholder":
          description: "String to replace newline characters values with"
          required: false
          defaultValue: " "
          type: "string"
        "fieldLimit":
          description: "The maximum number of characters allowed in each field of the incoming message"
          required: false
          defaultValue: 256
          type: "integer"
        "messageLimit":
          description: "The maximum number of characters allowed in the message after it has been formatted"
          required: false
          defaultValue: 4096
          type: "integer"
        "filters":
          bind-to-exchange: true
          description: "List of filters to match and format the data"
          required: false
          defaultValue: "NOT_SET"
          type: "array"
        "logReceived":
          description: "To log all received data, set this to true. The received file is logs/<pipeline name>-<yyyymmdd>.received"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "logSuccess":
          description: "To log messages that were successfully sent to the tcp destination, set this to true. The success file is logs/<pipeline name>-<yyyymmdd>.success"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "logFailed":
          description: "To log all failed data, set this to true. The failed file is logs/<pipeline name>-<yyyymmdd>.failed"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "logProcessed":
          description: "To log the data once processed into its final form, set this to true. The received file is logs/<pipeline name>-<yyyymmdd>.processed"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "uiMessageLimit":
          description: "Limit of failed/dropped/success/processed/received messages to display on the UI."
          required: false
          defaultValue: "200"
          type: "integer"

      uiSchema:
        type: object
        properties:
          dataSourceHeader:
            type: header
            title: Database
          dataSourceGroup:
            type: object
            ui:
              component: group
            properties:
              dataSourceConfig:
                type: grid
                ui:
                  columns:
                    - 25%
                    - auto
                  alignRow: baseline
                properties:
                  dataSourceConfigTitle:
                    type: grid
                    ui:
                      columns:
                        - auto
                        - 1fr
                      areas:
                        - description-text description-help
                      alignRow: center
                    properties:
                      description-text:
                        type: typography
                        defaultValue: Database Properties
                        ui:
                          indexed: true
                      description-help:
                        type: typography
                        help:
                          icon: info-circle
                          content: |-
                            ### Datasource Endpoint Properties

                              The following properties can be specified for the Datasource Endpoints:

                              | property | description |
                              | -- | -- |
                              | Schedule | The cron string that defines the schedule for this pipeline |
                              | Source Datasource | The data source name to use for the pipeline input |
                  dataSourceConfigValue:
                    type: object
                    properties:
                      fileConfigGrid:
                        type: grid
                        ui:
                          areas:
                            - cronSchedule dataSourceName dataSourceName dataSourceName
                            - . . . .
                          alignRow: baseline
                        properties:
                          cronSchedule:
                            type: cron
                            title: schedule
                            defaultValue: 0 0/1 * * * ? *
                          dataSourceName:
                            type: datasource
                            title: Source Datasource
                            ui:
                              dataSourceType: jdbc
          sqlSection:
            type: object
            properties:
              sqlHeader:
                type: header
                title: SQL Statements
              sqlContainer:
                type: object
                ui:
                  component: group
                properties:
                  sqlConfig:
                    type: grid
                    ui:
                      columns:
                        - 25%
                        - auto
                      alignRow: baseline
                    properties:
                      sqlTitle:
                        type: grid
                        ui:
                          columns:
                            - auto
                            - 1fr
                          areas:
                            - description-text description-help
                          alignRow: center
                        properties:
                          description-text:
                            type: typography
                            defaultValue: SQL Statement Properties
                            ui:
                              indexed: true
                          description-help:
                            type: typography
                            ui:
                              icon: info-circle
                            help:
                              icon: info-circle
                              content: |-
                                ### SQL Statement Properties

                                  The following properties can be specified for the source SQL statements.

                                  | property | description |
                                  | -- | -- |
                                  | Source SQL Statement | The SQL Statement to query data from the source datasource |
                                  | Checkpointing | Toggle to enable / disable checkpointing<br /><br />(_More info can be found within the SQL statement definitions_) |
                      sqlValue:
                        type: object
                        properties:
                          sqlGrid:
                            type: grid
                            ui:
                              columns:
                                - auto
                            properties:
                              sql:
                                type: array
                                title: SQL Statements
                                ui:
                                  columns:
                                    - 24%
                                    - 24%
                                    - 24%
                                    - 24%
                                  areas:
                                    - >-
                                      selectStatement selectStatement
                                      selectStatement selectStatement
                                    - checkpointEnabled . . .
                                    - >-
                                      checkpointType checkpointName checkpointKey
                                      checkpointDefault
                                  indexed: true
                                propertyTemplate:
                                  selectStatement:
                                    type: string
                                    title: Source SQL statement
                                    description: >-
                                      SQL statement to query data from the source
                                      database
                                    ui:
                                      rows: 4
                                    help:
                                      icon: info-circle
                                      content: >-
                                        ### Source SQL statement

                                        The SQL statement to execute against the source
                                        DataSource


                                        #### Specifying a checkpoint value in the source
                                        SQL statement


                                        ```

                                        # Select records from iss_pp_alerts_table and
                                        only return records > the last alertid from the
                                        previous execution

                                        SELECT * FROM iss_pp_alerts_table where alertid
                                        >= ${exchange.properties.checkpointValue}

                                        ```
                                  checkpointEnabled:
                                    type: switch
                                    title: Checkpointing
                                    help:
                                      icon: info-circle
                                      content: >-
                                        ### Checkpoints


                                        Using a checkpoint ensures only new data that
                                        matches your `sourceSqlStatement` is processed
                                        on each read.<br/><br /> Each time the
                                        `sourceSqlStatement` is executed, the checkpoint
                                        value from the previous execution is
                                        used.<br/><br />


                                        | Property | Description |

                                        | -------- | ----------- |

                                        | Checkpoint Type | The SQL data type (ie:
                                        `date`, `integer`, `text`) |

                                        | Checkpoint Name | Unique name for this
                                        checkpoint field |

                                        | Checkpoint Key | The field returned from the
                                        SQL source staement whose value is stored |

                                        | Checkpoint Default | A default value to set
                                        when the pipeline is first run, or if a value
                                        cannot be determined |


                                        <br />


                                        #### How to specify a checkpoint value in the
                                        source SQL statement


                                        In the example below, the checkpoint key is the
                                        `alertid`. This ensures that only rows where the
                                        `alertid` is greater than the previous execution
                                        are returned.<br/><br />


                                        ```

                                        # Select records from iss_pp_alerts_table and
                                        only return records > the last alertid from the
                                        previous execution

                                        SELECT * FROM iss_pp_alerts_table where alertid
                                        >= ${exchange.properties.checkpointValue}

                                        ```
                                  checkpointType:
                                    type: select
                                    title: Checkpoint Type
                                    ui:
                                      options:
                                        - field
                                        - date
                                  checkpointName:
                                    type: string
                                    title: Checkpoint Name
                                  checkpointKey:
                                    type: string
                                    title: Checkpoint Key
                                  checkpointDefault:
                                    type: string
                                    title: Checkpoint Default
          destinationSection:
            type: object
            properties:
              destinationHeader:
                type: header
                title: Destination Configuration
              destinationContainer:
                type: object
                ui:
                  component: group
                properties:
                  commandConfig:
                    type: grid
                    ui:
                      columns:
                        - 25%
                        - auto
                      alignRow: center
                    properties:
                      destinationTitle:
                        type: grid
                        ui:
                          columns:
                            - auto
                            - 1fr
                          areas:
                            - description-text description-help
                          alignRow: center
                        properties:
                          description-text:
                            type: typography
                            defaultValue: Destination Properties
                            ui:
                              indexed: true
                          description-help:
                            type: typography
                            ui:
                              icon: info-circle
                            help:
                              icon: info-circle
                              content: |-
                                ### Destination Properties

                                  The following properties can be specified for the destination.

                                  | property | description |
                                  | -- | -- |
                                  | Destination | Defines the output targets for this pipeline, specifying where the output will be directed |
                      destinationValue:
                        type: object
                        properties:
                          destinationGrid:
                            type: grid
                            ui:
                              columns:
                                - auto
                            properties:
                              destinationServers:
                                type: outputtarget
                                title: Destination
          optionalSettings:
            type: expansion-panel
            title: Optional Settings
            ui:
              elevation: 2
            properties:
              toggleFilter:
                type: switch
                title: Configure Filters
                defaultValue: false
              conditional-section-filters:
                type: conditional
                expression:
                  left: $toggleFilter
                  operator: "=="
                  right: true
                properties:
                  placeholders:
                    type: grid
                    ui:
                      columns:
                        - 30%
                        - 30%
                        - 20%
                        - auto
                    properties:
                      newlinePlaceholder:
                        type: string
                        title: Newline Placeholder
                        description: Replace newline characters with this value, defaults to a single space
                      blankPlaceholder:
                        type: string
                        title: Blank Placeholder
                        description: Replace blank keys with this value, defaults to a 'N/A'
                      fieldLimit:
                        type: string
                        title: Field Limit
                        defaultValue: 256
                      messageLimit:
                        type: string
                        title: Message Limit
                        defaultValue: 4096
                  filters:
                    type: array
                    title: filter and format messages
                    ui:
                      areas:
                        - expression format format split
                    propertyTemplate:
                      expression:
                        type: string
                        title: Expression
                        help:
                          icon: info-circle
                          content: |-
                            ### Simple Expressions

                            > **field** _operator_ **value**

                            ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                            ##### value: the value being tested against
                            ##### operators

                                ==          equals
                                =~          equals (case insensitive)
                                !=          does not equal
                                !=~         does not equal (case insensitive)
                                contains    contains string
                                !contains   does not contain
                                regex       matches regex expression
                                !regex      does not match regex expression
                                &&          AND multiple expressions
                                ||          OR multiple expressions

                            ##### See examples below

                                # match any string
                                ${bodyAs(String)} regex '(?s)(.*?)'
                                # incoming message contains 'this' but not 'that'
                                ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                                # incoming message contains 'dog' or 'cat'
                                ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                                # incoming message field 'username' equals 'ppadmin'
                                ${body.username} == 'ppadmin'
                                # incoming message field 'username' is not null
                                ${body.username} != null
                                # incoming message field 'origindate' equals todays date
                                ${body.origindate} == ${date:now:yyyyMMdd}
                      format:
                        type: string
                        title: Format
                        help:
                          icon: info-circle
                          content: |-
                            # Transform Format
                            The format output redefines how you wish to transform the message.

                            ## JSON Object example
                            incoming message

                                {
                                  "user": {
                                    "name": "ppadmin",
                                    "uid": 229,
                                    "group": "ppusers"
                                  },
                                  "origindate": "2022-12-15 12:01:34"
                                }

                            ### auto mapping
                            Auto transform format

                                UserAlert ${auto}

                            Transformed output

                                UserAlert datetime = 2022-12-15 12:01:34 | name = ppadmin | group = ppusers | Accept = text/plain, application/xml, text/xml, application/json, application/*+xml, application/*+json, */* |  Accept-Encoding = gzip,deflate |  Connection = keep-alive |  Content-Length = 114 |  Content-Type = application/json |  correlationId = 43CA053BE23B183-0000000000000002 |  Host = localhost:30052 |  HttpCharacterEncoding = UTF-8 |  HttpMethod = POST |  HttpPath = N/A |  HttpQuery = null |  HttpUri = / |  HttpUrl = [http://localhost:30052/](http://localhost:30052/) |  parentId = 43CA053BE23B183-0000000000000001 |  ServletContextPath = / |  User-Agent = Apache-HttpClient/4.5.13 (Java/1.8.0_241) |

                            ### pre-defined mapping

                            Pre-defined transform format
                                UserAlert datetime = ${body.origindate} | name = ${body.user.name} | group = ${body.user.group} |

                            Transformed output

                                UserAlert datetime = 2022-12-15 12:01:34 | name = ppadmin | group = ppusers |

                            ## JSON Array example
                            incoming message

                                {
                                  "testfield": "VALUE1",
                                  "testfield2": "VALUE2",
                                  "nested": {
                                    "nestedField": "hello",
                                  },
                                  "array": [
                                    "array1",
                                    "array2",
                                    "array3"
                                  ]
                                }

                            ### auto mapping
                            Auto transform format

                                UserAlert \${auto}

                            Transformed output

                                UserAlert array.0 = array1 |  array.1 = array2 |  array.2 = array3 |  testfield2 = VALUE2 |   nested.nestedField = hello |  testfield = VALUE1 |   Accept = text/plain, application/xml, text/xml, application/json, application/*+xml, application/*+json, */* |  Accept-Encoding = gzip,deflate |  Connection = keep-alive |  Content-Length = 114 |  Content-Type = application/json |  correlationId = 43CA053BE23B183-0000000000000002 |  Host = localhost:30052 |  HttpCharacterEncoding = UTF-8 |  HttpMethod = POST |  HttpPath = N/A |  HttpQuery = null |  HttpUri = / |  HttpUrl = [http://localhost:30052/](http://localhost:30052/) |  parentId = 43CA053BE23B183-0000000000000001 |  ServletContextPath = / |  User-Agent = Apache-HttpClient/4.5.13 (Java/1.8.0_241) |

                            ### pre-defined mapping

                            Pre-defined transform format

                                UserAlert firstOne = ${body.array[0]} | msg = ${body.nested.nestedField} |
                            Transformed output

                                UserAlert firstOne = array1 | msg = hello |
                      split:
                        type: string
                        title: Split
                        defaultValue: ${body}
                        help:
                          icon: info-circle
                          content: |-
                            # Split messages
                            The split expression allows you to split an payload containing an array in to multiple events, by default it will split the main body of the message

                            ## JSON Array example
                            By default it will split the payload if it is an array.
                            For example:

                                [
                                  {
                                    "user": {
                                      "name": "ppadmin",
                                      "uid": 229,
                                      "group": "ppusers"
                                    },
                                    "origindate": "2022-12-15 12:01:34"
                                  },
                                  {
                                    "user": {
                                      "name": "Jeff",
                                      "uid": 456,
                                      "group": "ppusers"
                                    },
                                    "origindate": "2022-12-15 15:56:27"
                                  }
                                ]

                            Will result in two messages being sent to the destination.

                            ### Specifying the split expression
                            If you wish to split over a nested array, you can define the path to the "array".
                            With an incoming message of:

                                {
                                  "data": [
                                    {
                                      "user": {
                                        "name": "ppadmin",
                                        "uid": 229,
                                        "group": "ppusers"
                                      },
                                      "origindate": "2022-12-15 12:01:34"
                                    },
                                    {
                                      "user": {
                                        "name": "Jeff",
                                        "uid": 456,
                                        "group": "ppusers"
                                      },
                                      "origindate": "2022-12-15 15:56:27"
                                    }
                                  ]
                                }

                            The split expression will be:
                                ${body.data}
              toggleLogs:
                type: switch
                title: Configure Logging
                defaultValue: false
              conditional-section-logs:
                type: conditional
                expression:
                  left: $toggleLogs
                  operator: '=='
                  right: true
                properties:
                  uiMessageLimit:
                    type: number
                    title: UI Message Limit
                    defaultValue: 200
                    description: >-
                      Limit of failed/dropped/success/processed/received messages to
                      display on the UI
                  logOptions:
                    type: grid
                    ui:
                      columns:
                        - auto
                        - auto
                        - auto
                        - auto
                        - auto
                      alignRow: baseline
                    properties:
                      logReceived:
                        defaultValue: true
                        type: checkbox
                        title: log messages received
                      logProcessed:
                        type: checkbox
                        title: log processed messages
                        defaultValue: true
                      logSucess:
                        defaultValue: true
                        type: checkbox
                        title: log success messages
                      logFailed:
                        defaultValue: true
                        type: checkbox
                        title: log failed messages

      pipelineFlow:
        - type: block
          label: Source Datasource
          icon: database
        - type: pipe
          children:
            - type: arrow
              forward: true
              pullBackward: true
            - type: block
              label: query
            - type: arrow
              forward: true
            - type: block
              label: filter
            - type: arrow
              forward: true
              pullForward: true
        - type: block
          icon: arrow-down-to-square
          label: "Forward to TCP Socket(s)"

      exceptions:
        # REF-EJC - Catch genric exception
        - catches:
            - "java.lang.Exception"
          handled:
            type: constant
            expression: true
          steps:
            # REF- - Log the error
            - method: log
              level: ERROR
              message: "Error processing data: ${exception}"
            # REF-ONW - Set header "Integration_HubHttpResponseCode" to 400
            - method: setHeader
              key: Integration_HubHttpResponseCode
              value:
                type: constant
                expression: 400
            - method: setHeader
              key: Content-Type
              value:
                type: constant
                expression: application/json
            # REF-31X - Set body to error message
            - method: setBody
              expression:
                type: simple
                expression: '{"status": "ERROR", "requestId": "${exchangeId}", "message": "Error processing the body.\nPlease check message channel logs for more details." }'
            - method: isslog
              message: "parentId=${exchange.properties[parentId]}  | failed() | Error processing the body, please check the logs for more details. Exception=${exception.message}"
              type: failed
              queueSize: $[[uiMessageLimit]]
              writeToFile: $[[logFailed]]
              writeToDatabase: $[[logFailed]]
            - method: stop

        # REF-YV9 - Failed to send on socket
        - catches:
            - "java.net.ConnectException"
          handled:
            type: constant
            expression: true
          steps:
            - method: log
              level: ERROR
              message: "Failed to send body to ${exchangeProperty.destinationHost}"
            - method: choice
              when:
                - predicate:
                    type: simple
                    expression: "${exchangeProperty.placeholders[logFailed]} != null && ${exchangeProperty.placeholders[logFailed]} == true"
                  steps:
                    # REF-4KD - Write log message to “failed” file
                    - method: isslog
                      message: "parentId=${exchange.properties[parentId]}  | failed(${exchange.properties['filterExpression']}) | [dest=${exchangeProperty.destinationHost}, message=${exchange.properties['internalProcessedMessage']}]"
                      type: failed
                      queueSize: $[[uiMessageLimit]]
                      writeToFile: $[[logFailed]]
                      writeToDatabase: $[[logFailed]]
            - method: stop

      # REF-GP2 - Run schedule
      steps:
        - method: from
          component: quartz
          properties:
            triggerName: "$[[pipeline.id]]Trigger"
            cron: "$[[cronSchedule]]"

        # REF- - Remove all headers
        - method: removeHeaders
          pattern: "*"

        # REF- - Store exchangeId as CorrelationId
        - method: setHeader
          key: correlationId
          value:
            type: simple
            expression: "${exchangeId}"

        - method: setProperty
          key: parentId
          value:
            type: "simple"
            expression: "${exchangeId}"

        - method: choice
          when:
            - predicate:
                type: simple
                expression: "${exchangeProperty.placeholders[sql]} != null && ${exchangeProperty.placeholders[sql]} != 'NOT_SET' && ${exchangeProperty.placeholders[sql]} is 'java.util.List' && ${exchangeProperty.placeholders[sql].size()} > 0"
              steps:
                # Loop through the sql
                - method: loop
                  expression:
                      type: simple
                      expression: "${exchangeProperty.placeholders[sql].size()}"
                  copy: false
                  steps:
                    - method: setProperty
                      key: loopIndex
                      value:
                        type: simple
                        expression: "${header.Integration_HubLoopIndex}"
                    - method: setProperty
                      key: "sqlConfig"
                      value:
                        type: groovy
                        expression: |

                          def loopIndex = exchange.properties.get("loopIndex")
                          def placeholders = exchange.properties.get("placeholders")
                          def sqlBlocks = placeholders.get("sql")
                          def sqlConfig = sqlBlocks[loopIndex]

                          if (!sqlConfig.containsKey('format')) {
                            sqlConfig.put("format", "\${auto}")
                          }

                          if (!sqlConfig.containsKey('checkpointEnabled')) {
                            sqlConfig.put("checkpointEnabled", false)
                          } else {
                              sqlConfig.put("checkpointEnabled", sqlConfig.get("checkpointEnabled").toBoolean())
                          }

                          if (!sqlConfig.containsKey('checkpointDefault')) {
                            sqlConfig.put("checkpointDefault", "now")
                          }

                          if (!sqlConfig.containsKey('checkpointType')) {
                            sqlConfig.put("checkpointType", "date")
                          }

                          if (!sqlConfig.containsKey('checkpointKey')) {
                            sqlConfig.put("checkpointKey", "yyyy-MM-dd'T'HH:mm:ss")
                          }

                          if (!sqlConfig.containsKey('checkpointName')) {
                            sqlConfig.put("checkpointName", "sqlConfig_${loopIndex}")
                          }

                          return sqlConfig

                    # REF- - Read from checkpoint
                    - method: checkpoint
                      properties:
                        action: "read"
                        name: "${exchangeProperty.sqlConfig[checkpointName]}"
                        type: "${exchangeProperty.sqlConfig[checkpointType]}"
                        default: "${exchangeProperty.sqlConfig[checkpointDefault]}"
                        enabled: "${exchangeProperty.sqlConfig[checkpointEnabled]}"
                        key: "${exchangeProperty.sqlConfig[checkpointKey]}"

                    # REF-98A - Set header "Integration_HubFreemarkerTemplate" to the SQL statement
                    - method: setHeader
                      key: Integration_HubFreemarkerTemplate
                      value:
                        type: "simple"
                        expression: "${exchangeProperty.sqlConfig[selectStatement]}"

                    # REF-BVG - Compile FTL template
                    - method: to
                      component: freemarker
                      properties:
                        resourceUri: dummy
                        allowTemplateFromHeader: true
                        allowContextMapAll: true

                    - method: log
                      level: DEBUG
                      message: "sql statement = ${body}"

                    # REF- - Set body to select statement
                    # - method: setBody
                    #   expression:
                    #     type: simple
                    #     expression: "${body}"

                    # REF-XDD - Execute the query in the database
                    - method: to
                      component: jdbc
                      properties:
                        dataSourceName: "$[[dataSourceName]]"
                        useHeadersAsParameters: true

                    # REF-88T - Loop over the returned rows
                    - method: split
                      expressions:
                        - type: simple
                          expression: "${body}"
                      steps:
                        # REF-258 - Store incoming message as "internalOrigMsg" property
                        - method: setProperty
                          key: internalOrigMsg
                          value:
                            type: "simple"
                            expression: "${body}"

                        # REF-L14 - IF logReceived is enabled
                        # REF- - Debug message
                        - method: log
                          level: "DEBUG"
                          message: "Writing body to received file"

                        # REF-H9Z - Log message to file
                        - method: isslog
                          message: "received | ${bodyAs(String)}"
                          type: received
                          queueSize: $[[uiMessageLimit]]
                          writeToFile: $[[logReceived]]
                          writeToDatabase: $[[logReceived]]

                        # REF- - Remove all Integration_HubFile headers
                        - method: removeHeaders
                          pattern: "Integration_HubFile*"
                        # REF- - Remove all Integration_HubJdbc headers
                        - method: removeHeaders
                          pattern: "Integration_HubJdbc*"

                    # REF-IS2 - If the message matches a template key
                    - method: choice
                      when:
                        - predicate:
                            type: simple
                            expression: "${exchangeProperty.placeholders[filters]} != null && ${exchangeProperty.placeholders[filters]} != 'NOT_SET' && ${exchangeProperty.placeholders[filters]} is 'java.util.List' && ${exchangeProperty.placeholders[filters].size()} > 0"
                          steps:
                            - method: setProperty
                              key: continueFilterLoop
                              value:
                                type: constant
                                expression: true
                            - method: setProperty
                              key: filterListSize
                              value:
                                type: simple
                                expression: "${exchangeProperty.placeholders[filters].size()}"
                            - method: doWhile
                              predicate:
                                type: simple
                                expression: "${exchangeProperty.continueFilterLoop}"
                              copy: false
                              steps:
                                - method: choice
                                  when:
                                    - predicate:
                                        type: groovy
                                        expression: |
                                          def loopIndex = exchange.properties.get('filterLoopIndex', "0") as int;
                                          def filterListSize = exchange.properties.get('filterListSize');
                                          if (loopIndex >= filterListSize) {
                                            // Exit from loop
                                            exchange.properties.put("continueFilterLoop", false)
                                            return false
                                          }
                                          def filters = exchange.properties.get('placeholders').get('filters')
                                          def filterExpression = filters[loopIndex].get('expression')

                                          exchange.properties.put("filterExpression", filterExpression)

                                          filterExpression = exchange.properties.get("filterExpression")
                                          language = exchange.getContext().resolveLanguage("simple")
                                          predicate = language.createPredicate(filterExpression)
                                          result = predicate.matches(exchange);
                                          exchange.properties.put("continueFilterLoop", !result)
                                          return result
                                      steps:
                                        - method: log
                                          level: "DEBUG"
                                          message: "filters expression(${exchangeProperty.filterExpression}) matches"
                                        - method: setProperty
                                          key: filterCheck
                                          value:
                                            type: "constant"
                                            expression: true
                                        - method: setProperty
                                          key: filterFormat
                                          value:
                                            type: "simple"
                                            expression: "${exchangeProperty.placeholders[filters].get(${exchangeProperty.filterLoopIndex}).getOrDefault('format', 'NOT_SET')}"
                                        - method: choice
                                          when:
                                            - predicate:
                                                type: "simple"
                                                expression: "${exchangeProperty.filterFormat.toString()} == 'NOT_SET'"
                                              steps:
                                                - method: setProperty
                                                  key: filterFormat
                                                  value:
                                                    type: "constant"
                                                    expression: "${auto}"
                                        - method: setProperty
                                          key: filterSplit
                                          value:
                                            type: "simple"
                                            expression: "${exchangeProperty.placeholders[filters].get(${exchangeProperty.filterLoopIndex}).getOrDefault('split', 'NOT_SET')}"
                                        - method: choice
                                          when:
                                            - predicate:
                                                type: "simple"
                                                expression: "${exchangeProperty.filterSplit.toString()} == 'NOT_SET'"
                                              steps:
                                                - method: setProperty
                                                  key: filterSplit
                                                  value:
                                                    type: "constant"
                                                    expression: "${body}"
                                  otherwise:
                                    - method: log
                                      level: "DEBUG"
                                      message: "filters expression(${exchangeProperty.filterExpression}) does not match"
                                    - method: setProperty
                                      key: filterCheck
                                      value:
                                        type: groovy
                                        expression: |
                                          prop = exchange.properties.getOrDefault("filterCheck", "NOT_SET")
                                          if (prop == "NOT_SET") {
                                            return false;
                                          } else {
                                            return prop;
                                          }
                                    - method: setProperty
                                      key: filterLoopIndex
                                      value:
                                        type: "groovy"
                                        expression: |
                                          def loopIndex = exchange.properties.get('filterLoopIndex') as int;
                                          return loopIndex + 1
                      otherwise:
                        - method: log
                          level: "DEBUG"
                          message: "No filters definitions"
                        - method: setProperty
                          key: filterCheck
                          value:
                            type: "constant"
                            expression: false

                    - method: choice
                      when:
                        - predicate:
                            type: "simple"
                            expression: "${exchangeProperty.filterCheck.toString()} =~ 'false'"
                          steps:
                            - method: setProperty
                              key: filterFormat
                              value:
                                type: "constant"
                                expression: "${auto}"
                            - method: setProperty
                              key: filterExpression
                              value:
                                type: "constant"
                                expression: "DEFAULT"
                            - method: setProperty
                              key: filterSplit
                              value:
                                type: "constant"
                                expression: "${body}"

                    # REF- - Debug message
                    - method: log
                      level: "DEBUG"
                      message: "body '${body}' has matched template statement '${exchangeProperty.filterExpression}'"
                    # REF-8R9 - Set property "internalMatchFound" to true
                    - method: setProperty
                      key: internalMatchFound
                      value:
                        type: "constant"
                        expression: true

                    # REF- - Debug message
                    - method: log
                      level: "DEBUG"
                      message: "splitting body using '${exchangeProperty.filterSplit}'"
                    # REF-SLB - Split payload if array
                    - method: split
                      resolve-maps-as-key-value: false
                      aggregation-strategy:
                        type: collect-to-property
                      expressions:
                        - type: groovy
                          expression: |
                            filterSplitExpression = exchange.properties.get("filterSplit")
                            language = exchange.getContext().resolveLanguage("simple")
                            expression = language.createExpression(filterSplitExpression)
                            return expression.evaluate(exchange);
                      steps:
                        # REF- - Store split message as "internalSplitMsg" header
                        - method: setProperty
                          key: internalSplitMsg
                          value:
                            type: "simple"
                            expression: "${body}"

                        # REF- - Set Body to contents of property "internalSplitMsg"
                        - method: setBody
                          expression:
                            type: simple
                            expression: "${exchange.properties[internalSplitMsg]}"

                        # REF- - Restore original headers
                        - method: process
                          classname: com.interlinksoftware.integrationhub.config.step.processor.RestoreOriginHeadersProcessor
                        # REF- - Cleanse headers
                        - method: process
                          classname: com.interlinksoftware.integrationhub.config.step.processor.CleanseHeadersProcessor

                        # REF- - Store exchangeId as CorrelationId
                        - method: setHeader
                          key: correlationId
                          value:
                            type: simple
                            expression: "${exchangeId}"

                        # REF- - Remove Authorization header
                        - method: removeHeader
                          key: Authorization

                        - method: alertFormat
                          blankPlaceholder: "$[[blankPlaceholder]]"
                          newlinePlaceholder: "$[[newlinePlaceholder]]"
                          fieldLimit: $[[fieldLimit]]
                          messageLimit: $[[messageLimit]]

                        # REF-1Z8 - Set property "internalProcessedMessage" to body
                        - method: setProperty
                          key: internalProcessedMessage
                          value:
                            type: "simple"
                            expression: "${body}"

                        # REF-3P0 - If logProcessed is enabled
                        # REF- - Debug message
                        - method: log
                          level: "DEBUG"
                          message: "writing to proccessed file"
                        # REF-4MH - Log message to file
                        - method: isslog
                          message: "parentId=${exchange.properties[parentId]}  | processed(${exchange.properties['filterExpression']}) | ${bodyAs(String)}"
                          type: processed
                          queueSize: $[[uiMessageLimit]]
                          writeToFile: $[[logProcessed]]
                          writeToDatabase: $[[logProcessed]]

                        - method: setBody
                          expression:
                            type: simple
                            expression: ${exchange.properties[internalProcessedMessage]}

                        - method: destination
                          outputRefExpression: ${exchangeProperty.placeholders[destinationServers]}

                        # REF- - Set body to the orig message to allow checkpointing to use it
                        - method: setBody
                          expression:
                            type: simple
                            expression: "${exchange.properties[internalOrigMsg]}"

                        # REF- - Write to checkpoint
                        - method: checkpoint
                          properties:
                            action: "write"
                            name: "${exchangeProperty.sqlConfig[checkpointName]}"
                            type: "${exchangeProperty.sqlConfig[checkpointType]}"
                            default: "${exchangeProperty.sqlConfig[checkpointDefault]}"
                            enabled: "${exchangeProperty.sqlConfig[checkpointEnabled]}"
                            key: "${exchangeProperty.sqlConfig[checkpointKey]}"