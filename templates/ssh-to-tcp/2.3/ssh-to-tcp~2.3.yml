shared:
  templates:
    "[ssh-to-tcp~2.3]":
      version: "2.3"
      minimumCompatibilityVersion: 2.2.0
      description: "The ssh-to-tcp template provides functionality to transfer, filter/transform and send output from a remote SSH command/script to a TCP listener, via an integration-hub pipeline."
      placeholders:
        "schedule":
          description: "The cron expression that defines the execution schedule for this pipeline"
          required: false
          defaultValue: "0 * * ? * *"
          type: "string"
        "hostname":
          description: "The hostname or IP address of the remote server"
          required: true
          type: string
        "port":
          description: "The port that the remote server's SSH service is listening on"
          required: false
          type: integer
          defaultValue: 22
        "privateKeyAuth":
          description: "Toggle for switching between password / private key authentication"
          bind-to-exchange: true
          required: false
          type: boolean
          defaultValue: false
        "certResource":
          description: "Full path to the private key (if 'privateKeyAuth' is enabled)"
          required: false
          type: string
          defaultValue: ""
        "certResourcePassword":
          description: "The password to use for the private key (if 'privateKeyAuth' is enabled)"
          required: false
          valueType: encrypted
          defaultValue: ""
        "username":
          description: "Username to use when authenticating against the remote SSH server"
          required: true
          type: string
          defaultValue: ""
        "password":
          description: "Password to use when authenticating against the remote SSH server"
          required: false
          valueType: encrypted
          defaultValue: ""
        "pollCommand":
          description: "The command OR full path to the script you wish to execute on the remote SSH server"
          bind-to-exchange: true
          required: true
          type: string
        "timeout":
          description: "The timeout in milliseconds to wait in establishing the remote SSH server connection"
          required: false
          type: long
          defaultValue: 30000
        "destinationServers":
          description: "List of servers to send the pipeline output to"
          bind-to-exchange: true
          required: true
          type: "array"
        "blankPlaceholder":
          description: "String to replace blank values with"
          required: false
          defaultValue: "N/A"
          type: "string"
        "allowList":
          bind-to-exchange: true
          description: "List of logic statements to determine if the request can proceed"
          required: false
          defaultValue: "NOT_SET"
          type: "array"
        "denyList":
          bind-to-exchange: true
          description: "List of logic statements to halt the request"
          required: false
          defaultValue: "NOT_SET"
          type: "array"
        "filters":
          bind-to-exchange: true
          description: "List of filters to match and format the data"
          required: false
          defaultValue: "NOT_SET"
          type: "array"
        "logProcessed":
          description: "To log the data once processed into its final form, set this to true. The received file is logs/<pipeline name>-<yyyymmdd>.processed"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "logSuccess":
          description: "To log messages that were successfully sent to the tcp destination, set this to true. The success file is logs/<pipeline name>-<yyyymmdd>.success"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "logReceived":
          description: "To log all received data, set this to true. The received file is logs/<pipeline name>-<yyyymmdd>.received"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "logFailed":
          description: "To log all failed data, set this to true. The failed file is logs/<pipeline name>-<yyyymmdd>.failed"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "logDropped":
          description: "To log all dropped data, set this to true. The dropped file is logs/<pipeline name>-<yyyymmdd>.dropped"
          bind-to-exchange: true
          required: false
          type: "boolean"
          defaultValue: true
        "newlinePlaceholder":
          description: "String to replace newline characters values with"
          required: false
          defaultValue: " "
          type: "string"
        "preprocessHeaders":
          description: ""
          required: false
          defaultValue: "NOT_SET"
          bind-to-exchange: true
          type: "array"
        "uiMessageLimit":
          description: "Limit of failed/success/processed/received messages to display on the UI."
          required: false
          defaultValue: "200"
          type: "integer"
      uiSchema:
        type: object
        properties:
          remoteHostHeader:
            type: header
            title: SSH Remote Host Configuration
          remoteHost:
            type: object
            ui:
              component: group
            properties:
              remoteConfig:
                type: grid
                ui:
                  columns:
                    - 25%
                    - auto
                  alignRow: baseline
                properties:
                  remoteHostTitle:
                    type: grid
                    ui:
                      columns:
                        - auto
                        - 1fr
                      areas:
                        - description-text description-help
                      alignRow: center
                    properties:
                      description-text:
                        type: typography
                        defaultValue: Remote Host Properties
                        ui:
                          indexed: true
                      description-help:
                        type: typography
                        help:
                          icon: info-circle
                          content: |-
                            ### Remote Host Properties

                              The following properties can be specified for the remote host.

                              | property | description |
                              | -- | -- |
                              | hostname | The hostname or IP address of the remote SSH server |
                              | port | The port number that SSH on the remote server is listening on |
                              | username | The username to use when connecting to the remote SSH server |
                              | Use private key authentication | Toggle between private key authentication or basic authentication |
                              | password | The password for the user you want to authenticate as |
                              | Private Key File | Full path to where the private key is stored |
                              | Private Key Password | Password for the private key (_Leave blank if a password is not required_) |
                  remoteHostValue:
                    type: object
                    properties:
                      remoteHostConnection:
                        type: grid
                        ui:
                          columns:
                            - 70%
                            - auto
                        properties:
                          hostname:
                            type: string
                            title: hostname
                            defaultValue: 0.0.0.0
                            validation:
                              required: true
                              message: "Please enter a valid hostname"
                          port:
                            type: number
                            title: port
                            defaultValue: 22
                            validation:
                              regex: ^[0-9]+$
                              message: specify port number >1024
                              required: true
                      remoteHostAuthentication:
                        type: grid
                        ui:
                          columns:
                            - auto
                        properties:
                          username:
                            type: string
                            title: Username
                            validation:
                              required: true
                              message: Username must be set
                          privateKeyAuth:
                            type: switch
                            title: Use private key authentication?
                            defaultValue: false
                          conditional-section-true:
                            type: conditional
                            expression:
                              left: $privateKeyAuth
                              operator: "=="
                              right: true
                            properties:
                              certResource:
                                type: string
                                title: Private Key File
                                description: Full path to where the private key is stored
                                disabled: true
                              certResourcePassword:
                                type: password
                                title: Private Key Password
                                description: Password for the private key (Leave blank if a password is not required)
                                disabled: true
                          conditional-section-false:
                            type: conditional
                            expression:
                              left: $privateKeyAuth
                              operator: "!="
                              right: true
                            properties:
                              password:
                                type: password
                                title: Password
                                disabled: true
          commandSection:
            type: object
            properties:
              commandHeader:
                type: header
                title: Remote Command Configuration
              commandContainer:
                type: object
                ui:
                  component: group
                properties:
                  commandConfig:
                    type: grid
                    ui:
                      columns:
                        - 25%
                        - auto
                      alignRow: baseline
                    properties:
                      commandTitle:
                        type: grid
                        ui:
                          columns:
                            - auto
                            - 1fr
                          areas:
                            - description-text description-help
                          alignRow: center
                        properties:
                          description-text:
                            type: typography
                            defaultValue: Command Properties
                            ui:
                              indexed: true
                          description-help:
                            type: typography
                            ui:
                              icon: info-circle
                            help:
                              icon: info-circle
                              content: |-
                                ### Command

                                  The following properties can be specified for the command.

                                  | property | description |
                                  | -- | -- |
                                  | schedule | The interval at which you would like the command / script to run |
                                  | command / script | The command string to send to the remote SSH server |
                                  | timeout | The timeout in **milliseconds** to wait in establishing the remote SSH server connection |
                                  | newlinePlaceholder | Replace newline characters within the incoming message |
                                  | blankPlaceholder | Replace blank keys within the incoming message |
                      commandValue:
                        type: object
                        properties:
                          remoteHostConnection:
                            type: grid
                            ui:
                              areas:
                                - "schedule schedule schedule schedule"
                                - "pollCommand timeout newlinePlaceholder blankPlaceholder"
                            properties:
                              schedule:
                                type: cron
                                title: schedule
                                defaultValue: 0 0/1 * * * ?
                              pollCommand:
                                type: string
                                title: Command / Script
                                validation:
                                  required: true
                                  message: Please enter a command / script to run
                              timeout:
                                type: number
                                title: timeout
                                defaultValue: 30000
                              newlinePlaceholder:
                                type: string
                                title: Newline Placeholder
                              blankPlaceholder:
                                type: string
                                title: Blank Placeholder
          destinationSection:
            type: object
            properties:
              destinationHeader:
                type: header
                title: Destination Configuration
              destinationContainer:
                type: object
                ui:
                  component: group
                properties:
                  commandConfig:
                    type: grid
                    ui:
                      columns:
                        - 25%
                        - auto
                      alignRow: baseline
                    properties:
                      destinationTitle:
                        type: grid
                        ui:
                          columns:
                            - auto
                            - 1fr
                          areas:
                            - description-text description-help
                          alignRow: center
                        properties:
                          description-text:
                            type: typography
                            defaultValue: Destination Properties
                            ui:
                              indexed: true
                          description-help:
                            type: typography
                            ui:
                              icon: info-circle
                            help:
                              icon: info-circle
                              content: |-
                                ### Desintation Properties

                                  The following properties can be specified for the destination.

                                  | property | description |
                                  | -- | -- |
                                  | hostname | The hostname or IP address of the TCP listener this pipeline will forward messages to |
                                  | port | The port that the TCP channel is listening on |
                      destinationValue:
                        type: object
                        properties:
                          destinationGrid:
                            type: grid
                            ui:
                              columns:
                                - auto
                            properties:
                              destinationServers:
                                type: array
                                title: destination servers to forward messages to
                                ui:
                                  columns:
                                    - auto
                                    - auto
                                validation:
                                  message: "Please define one destination host"
                                  required: true
                                propertyTemplate:
                                  hostname:
                                    type: string
                                    title: hostname
                                    validation:
                                      message: "Please specify a valid hostname"
                                      required: true
                                  port:
                                    type: number
                                    title: port
                                    validation:
                                      regex: ^[0-9]+$
                                      message: specify port number >1024
          optionalSettings:
            type: expansion-panel
            title: Optional Settings
            ui:
              elevation: 2
            properties:
              togglePreprocessHeaders:
                type: switch
                title: Configure Pre-process Headers
                defaultValue: false
              conditional-section-preprocessHeaders:
                type: conditional
                expression:
                  left: $togglePreprocessHeaders
                  operator: "=="
                  right: true
                properties:
                  preprocessHeaders:
                    type: array
                    title: Pre-processing Headers Override
                    ui:
                      columns:
                        - auto
                        - auto
                    propertyTemplate:
                      expression:
                        type: text
                        title: The expression to match
                        help:
                          icon: info-circle
                          content: |-
                            ### Simple Expressions

                            > **field** _operator_ **value**

                            ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                            ##### value: the value being tested against
                            ##### operators

                                ==          equals
                                =~          equals (case insensitive)
                                !=          does not equal
                                !=~         does not equal (case insensitive)
                                contains    contains string
                                !contains   does not contain
                                regex       matches regex expression
                                !regex      does not match regex expression
                                &&          AND multiple expressions
                                ||          OR multiple expressions

                            ##### See examples below

                                # match any string
                                ${bodyAs(String)} regex '(?s)(.*?)'
                                # incoming message contains 'this' but not 'that'
                                ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                                # incoming message contains 'dog' or 'cat'
                                ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                                # incoming message field 'username' equals 'ppadmin'
                                ${body.username} == 'ppadmin'
                                # incoming message field 'username' is not null
                                ${body.username} != null
                                # incoming message field 'origindate' equals todays date
                                ${body.origindate} == ${date:now:yyyyMMdd}
                      headers:
                        type: map
                        title: Headers
                        ui:
                          keyPlaceholder: Header Name
                        valueSchema:
                          type: text
                          ui:
                            placeholder: Header Value
              toggleAllowDenyList:
                type: switch
                title: Configure Allow/Deny List
                defaultValue: false
              conditional-section-allow-deny:
                type: conditional
                expression:
                  left: $toggleAllowDenyList
                  operator: "=="
                  right: true
                properties:
                  allowList:
                    type: array
                    title: Allow list (process if expression is matched)
                    ui:
                      indexed: true
                    help:
                      icon: info-circle
                      content: |-
                        ### Simple Expressions

                        > **field** _operator_ **value**

                        ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                        ##### value: the value being tested against
                        ##### operators

                            ==          equals
                            =~          equals (case insensitive)
                            !=          does not equal
                            !=~         does not equal (case insensitive)
                            contains    contains string
                            !contains   does not contain
                            regex       matches regex expression
                            !regex      does not match regex expression
                            &&          AND multiple expressions
                            ||          OR multiple expressions

                        ##### See examples below

                            # match any string
                            ${bodyAs(String)} regex '(?s)(.*?)'
                            # incoming message contains 'this' but not 'that'
                            ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                            # incoming message contains 'dog' or 'cat'
                            ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                            # incoming message field 'username' equals 'ppadmin'
                            ${body.username} == 'ppadmin'
                            # incoming message field 'username' is not null
                            ${body.username} != null
                            # incoming message field 'origindate' equals todays date
                            ${body.origindate} == ${date:now:yyyyMMdd}
                  denyList:
                    type: array
                    title: Deny list (drop if expression is matched)
                    ui:
                      indexed: true
                    help:
                      icon: info-circle
                      content: |-
                        ### Simple Expressions

                        > **field** _operator_ **value**

                        ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                        ##### value: the value being tested against
                        ##### operators

                            ==          equals
                            =~          equals (case insensitive)
                            !=          does not equal
                            !=~         does not equal (case insensitive)
                            contains    contains string
                            !contains   does not contain
                            regex       matches regex expression
                            !regex      does not match regex expression
                            &&          AND multiple expressions
                            ||          OR multiple expressions

                        ##### See examples below

                            # match any string
                            ${bodyAs(String)} regex '(?s)(.*?)'
                            # incoming message contains 'this' but not 'that'
                            ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                            # incoming message contains 'dog' or 'cat'
                            ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                            # incoming message field 'username' equals 'ppadmin'
                            ${body.username} == 'ppadmin'
                            # incoming message field 'username' is not null
                            ${body.username} != null
                            # incoming message field 'origindate' equals todays date
                            ${body.origindate} == ${date:now:yyyyMMdd}
              toggleFilter:
                type: switch
                title: Configure Filters
                defaultValue: false
              conditional-section-filters:
                type: conditional
                expression:
                  left: $toggleFilter
                  operator: "=="
                  right: true
                properties:
                  filters:
                    type: array
                    title: filter and format messages
                    ui:
                      columns:
                        - 30%
                        - auto
                    propertyTemplate:
                      expression:
                        type: string
                        title: Expression
                        description: 'Simple Expression (ie: ${bodyAs(String)} contains ''EVENT'')'
                        help:
                          icon: info-circle
                          content: |-
                            ### Simple Expressions

                            > **field** _operator_ **value**

                            ##### field: the field that referenced from the incoming message. To match against the whole string use **\${bodyAs(String)}** , to reference a specific field use **\${body.hostname}**
                            ##### value: the value being tested against
                            ##### operators

                                ==          equals
                                =~          equals (case insensitive)
                                !=          does not equal
                                !=~         does not equal (case insensitive)
                                contains    contains string
                                !contains   does not contain
                                regex       matches regex expression
                                !regex      does not match regex expression
                                &&          AND multiple expressions
                                ||          OR multiple expressions

                            ##### See examples below

                                # match any string
                                ${bodyAs(String)} regex '(?s)(.*?)'
                                # incoming message contains 'this' but not 'that'
                                ${bodyAs(String)} =~ 'this' && ${bodyAs(String)} !=~ 'that'
                                # incoming message contains 'dog' or 'cat'
                                ${bodyAs(String)} =~ 'dog' || ${bodyAs(String)} !=~ 'cat'
                                # incoming message field 'username' equals 'ppadmin'
                                ${body.username} == 'ppadmin'
                                # incoming message field 'username' is not null
                                ${body.username} != null
                                # incoming message field 'origindate' equals todays date
                                ${body.origindate} == ${date:now:yyyyMMdd}
                      format:
                        type: string
                        title: Format
                        description: 'Target Format (ie: AUTO | ${auto}'
                        help:
                          icon: info-circle
                          content: |-
                            # Transform Format
                            The format output redefines how you wish to transform the message.

                            ## JSON Object example
                            incoming message

                                {
                                  "user": {
                                    "name": "ppadmin",
                                    "uid": 229,
                                    "group": "ppusers"
                                  },
                                  "origindate": "2022-12-15 12:01:34"
                                }

                            ### auto mapping
                            Auto transform format

                                UserAlert ${auto}

                            Transformed output

                                UserAlert datetime = 2022-12-15 12:01:34 | name = ppadmin | group = ppusers | Accept = text/plain, application/xml, text/xml, application/json, application/*+xml, application/*+json, */* |  Accept-Encoding = gzip,deflate |  Connection = keep-alive |  Content-Length = 114 |  Content-Type = application/json |  correlationId = 43CA053BE23B183-0000000000000002 |  Host = localhost:30052 |  HttpCharacterEncoding = UTF-8 |  HttpMethod = POST |  HttpPath = N/A |  HttpQuery = null |  HttpUri = / |  HttpUrl = [http://localhost:30052/](http://localhost:30052/) |  parentId = 43CA053BE23B183-0000000000000001 |  ServletContextPath = / |  User-Agent = Apache-HttpClient/4.5.13 (Java/1.8.0_241) |

                            ### pre-defined mapping

                            Pre-defined transform format
                                UserAlert datetime = ${body.origindate} | name = ${body.user.name} | group = ${body.user.group} |

                            Transformed output

                                UserAlert datetime = 2022-12-15 12:01:34 | name = ppadmin | group = ppusers |

                            ## JSON Array example
                            incoming message

                                {
                                  "testfield": "VALUE1",
                                  "testfield2": "VALUE2",
                                  "nested": {
                                    "nestedField": "hello",
                                  },
                                  "array": [
                                    "array1",
                                    "array2",
                                    "array3"
                                  ]
                                }

                            ### auto mapping
                            Auto transform format

                                UserAlert ${auto}

                            Transformed output

                                UserAlert array.0 = array1 |  array.1 = array2 |  array.2 = array3 |  testfield2 = VALUE2 |   nested.nestedField = hello |  testfield = VALUE1 |   Accept = text/plain, application/xml, text/xml, application/json, application/*+xml, application/*+json, */* |  Accept-Encoding = gzip,deflate |  Connection = keep-alive |  Content-Length = 114 |  Content-Type = application/json |  correlationId = 43CA053BE23B183-0000000000000002 |  Host = localhost:30052 |  HttpCharacterEncoding = UTF-8 |  HttpMethod = POST |  HttpPath = N/A |  HttpQuery = null |  HttpUri = / |  HttpUrl = [http://localhost:30052/](http://localhost:30052/) |  parentId = 43CA053BE23B183-0000000000000001 |  ServletContextPath = / |  User-Agent = Apache-HttpClient/4.5.13 (Java/1.8.0_241) |

                            ### pre-defined mapping

                            Pre-defined transform format

                                UserAlert firstOne = ${body.array[0]} | msg = ${body.nested.nestedField} |
                            Transformed output

                                UserAlert firstOne = array1 | msg = hello |
                      splitType:
                        type: select
                        title: Split Type
                        defaultValue: Default
                        ui:
                          options:
                            - Default
                            - Tokenize
                      split:
                        type: string
                        title: Split
                        defaultValue: ${body}
                        help:
                          icon: info-circle
                          content: |-
                            # Split expression
                            The split expression allows you to split a payload containing an array into multiple events.

                            ### Split Type: [`Default`]

                            The default behavior will split the main body of the message.

                            #### JSON Array example
                            Let's take the following JSON Array for example:

                            ```
                            [
                              {
                                "user": {
                                  "name": "ppadmin",
                                  "uid": 229,
                                  "group": "ppusers"
                                },
                                "origindate": "2022-12-15 12:01:34"
                              },
                              {
                                "user": {
                                  "name": "Jeff",
                                  "uid": 456,
                                  "group": "ppusers"
                                },
                                "origindate": "2022-12-15 15:56:27"
                              }
                            ]
                            ```

                            Using the default `${body}` split expression, will result in two messages being sent to the destination.

                            #### Specifying the split expression
                            If you wish to split over a nested array, you can define the path to the "array".

                            Let take the following message:

                            ```
                            {
                              "data": [
                                {
                                  "user": {
                                    "name": "ppadmin",
                                    "uid": 229,
                                    "group": "ppusers"
                                  },
                                  "origindate": "2022-12-15 12:01:34"
                                },
                                {
                                  "user": {
                                    "name": "Jeff",
                                    "uid": 456,
                                    "group": "ppusers"
                                  },
                                  "origindate": "2022-12-15 15:56:27"
                                }
                              ]
                            }
                            ```

                            In order to access the information within the `data` array, we would define the split expression as follows:

                            `${body[data]}`

                            ---

                            ### Split Type: [`Tokenize`]

                            Tokenize allows you to split a payload that lacks an array structure into multiple separate events.

                            #### Log Snippet Example

                            Let's take the following payload tha contains a snippet of logs:

                            ```
                            Oct  9 16:02:00 vmss systemd-logind: Removed session 86751.
                            Oct  9 16:03:00 vmss systemd-logind: New session 86754 of user root.
                            Oct  9 16:03:00 vmss systemd: Started Session 86754 of user root.
                            Oct  9 16:03:00 vmss systemd-logind: Removed session 86753.
                            Oct  9 16:04:00 vmss systemd-logind: New session 86755 of user root.
                            Oct  9 16:04:00 vmss systemd: Started Session 86755 of user root.
                            Oct  9 16:04:00 vmss systemd-logind: Removed session 86754.
                            Oct  9 16:05:00 vmss systemd-logind: New session 86756 of user root.
                            Oct  9 16:05:00 vmss systemd: Started Session 86756 of user root.
                            Oct  9 16:05:00 vmss systemd-logind: Removed session 86755.
                            Oct  9 16:05:54 vmss systemd-logind: Removed session 86756.
                            ```

                            To split the payload so that each line in the log snippet generates an individual message, we define the split expression as follows:

                            `\n`

                            This instructs the pipeline to split the payload at every newline character.
              toggleLogs:
                type: switch
                title: Configure Logging
                defaultValue: false
              conditional-section-logs:
                type: conditional
                expression:
                  left: $toggleLogs
                  operator: "=="
                  right: true
                properties:
                  uiMessageLimit:
                    type: number
                    title: UI Message Limit
                    defaultValue: 50
                    description: >-
                      Limit of failed/dropped/success/processed/received messages to display on the UI
                  logOptions:
                    type: grid
                    ui:
                      columns:
                        - auto
                        - auto
                        - auto
                        - auto
                        - auto
                      alignRow: baseline
                    properties:
                      logReceived:
                        defaultValue: true
                        type: checkbox
                        title: log messages received
                      logDropped:
                        defaultValue: true
                        type: checkbox
                        title: log dropped messages
                      logProcessed:
                        type: checkbox
                        title: log processed messages
                        defaultValue: true
                      logSuccess:
                        defaultValue: true
                        type: checkbox
                        title: log success messages
                      logFailed:
                        defaultValue: true
                        type: checkbox
                        title: log failed messages
      pipelineFlow:
        - type: block
          label: SSH Remote Command Output
          icon: terminal
        - type: pipe
          children:
            - type: arrow
              forward: true
              pullBackward: true
            - type: block
              label: drop
              icon: trash-can
            - type: arrow
              forward: true
            - type: block
              label: filter
              icon: filter
            - type: arrow
              forward: true
            - type: block
              label: transform
              icon: shuffle
            - type: arrow
              forward: true
              pullForward: true
        - type: block
          icon: arrow-down-to-square
          label: "Forward to TCP Socket(s)"
      exceptions:
        # REF-EJC - Catch genric exception
        - catches:
            - "java.lang.Exception"
          handled:
            type: constant
            expression: true
          steps:
            # REF- - Log the error
            - method: log
              level: ERROR
              message: "Error processing data: ${exception}"
            # REF-ONW - Set header "Integration_HubHttpResponseCode" to 400
            - method: setHeader
              key: Integration_HubHttpResponseCode
              value:
                type: constant
                expression: 400
            - method: setHeader
              key: Content-Type
              value:
                type: constant
                expression: application/json
            # REF-31X - Set body to error message
            - method: setBody
              expression:
                type: simple
                expression: '{"status": "ERROR", "requestId": "${exchangeId}", "message": "Error processing the body.\nPlease check message channel logs for more details." }'
            - method: isslog
              message: "parentId=${headers.parentId} | failed() | Error processing the body, please check the logs for more details. Exception=${exception.message}"
              type: failed
              queueSize: $[[uiMessageLimit]]
              writeToFile: $[[logFailed]]
              writeToDatabase: $[[logFailed]]
            - method: stop
        # REF-M0L - Catch No payload
        - catches:
            - "org.apache.integration_hub.NoTypeConversionAvailableException"
            - "com.fasterxml.jackson.databind.exc.MismatchedInputException"
          handled:
            type: constant
            expression: true
          steps:
            # REF- - Log the error
            - method: log
              level: ERROR
              message: "No content in the payload: ${exception}"
            # REF-PO0 - Set header "Integration_HubHttpResponseCode" to 400
            - method: setHeader
              key: Integration_HubHttpResponseCode
              value:
                type: constant
                expression: 400
            - method: setHeader
              key: Content-Type
              value:
                type: constant
                expression: application/json
            # REF-31X - Set body to error message
            - method: setBody
              expression:
                type: simple
                expression: '{"status": "ERROR", "requestId": "${exchangeId}", "message": "Error no content in the body" }'
            - method: isslog
              message: "parentId=${headers.parentId} | failed() | No content in body. Exception=${exception.message}"
              type: failed
              queueSize: $[[uiMessageLimit]]
              writeToFile: $[[logFailed]]
              writeToDatabase: $[[logFailed]]
            - method: stop
        # REF-XAG - Failed to send on socket
        - catches:
            - "java.net.ConnectException"
          handled:
            type: constant
            expression: true
          steps:
            # REF- - Log the error
            - method: log
              level: "ERROR"
              message: "Failed to send body to ${exchangeProperty.destinationHost}"
            - method: choice
              when:
                - predicate:
                    type: simple
                    expression: "${exchangeProperty.placeholders[logFailed]} != null && ${exchangeProperty.placeholders[logFailed]} == true"
                  steps:
                    # REF-4KD - Write log message to “failed” file
                    - method: isslog
                      message: "parentId=${headers.parentId} | failed(${exchange.properties['filterExpression']}) | [dest=${exchangeProperty.destinationHost}, message=${exchange.properties['internalProcessedMessage']}]"
                      type: failed
                      queueSize: $[[uiMessageLimit]]
                      writeToFile: $[[logFailed]]
                      writeToDatabase: $[[logFailed]]
            - method: stop
      steps:
        - method: from
          component: quartz
          properties:
            triggerName: "$[[pipeline.id]]Trigger"
            startDelayedSeconds: 0
            triggerStartDelay: 0
            cron: "$[[schedule]]"
        # Set body to pollCommand for the ssh producer to use
        - method: setBody
          expression:
            type: simple
            expression: "${exchangeProperty.placeholders[pollCommand]}"
        - method: choice
          when:
            - predicate:
                type: simple
                expression: "${exchangeProperty.placeholders[privateKeyAuth]} == false"
              steps:
                - method: to
                  component: ssh
                  properties:
                    host: $[[hostname]]
                    port: $[[port]]
                    username: $[[username]]
                    password: $[[password]]
          otherwise:
            - method: to
              component: ssh
              properties:
                host: $[[hostname]]
                port: $[[port]]
                username: $[[username]]
                certResource: "file:$[[certResource]]"
                certResourcePassword: $[[certResourcePassword]]
        # REF-B9G - Store incoming message as "internalOrigMsg" property
        - method: setProperty
          key: internalOrigMsg
          value:
            type: "simple"
            expression: "${body}"
        # REF- - Set header "requestId" to the initial "parent" correlationId
        - method: setHeader
          key: parentId
          value:
            type: "simple"
            expression: "${exchangeId}"
        # REF- - Store headers in exchange
        - method: process
          classname: com.interlinksoftware.integrationhub.config.step.processor.HeadersToPropertyProcessor
        # REF-L14 - IF logReceived is enabled
        - method: choice
          when:
            - predicate:
                type: simple
                expression: "${exchangeProperty.placeholders[logReceived]} != null && ${exchangeProperty.placeholders[logReceived]} == true"
              steps:
                # REF- - Debug message
                - method: log
                  level: "DEBUG"
                  message: "Writing body to received file"
                # REF-H9Z - Log message to file
                - method: isslog
                  message: "received | ${bodyAs(String)}"
                  type: received
                  queueSize: $[[uiMessageLimit]]
                  writeToFile: $[[logReceived]]
                  writeToDatabase: $[[logReceived]]
        # REF- - Set body to origin message
        - method: setBody
          expression:
            type: simple
            expression: "${exchangeProperty.internalOrigMsg}"
        - method: choice
          when:
            - predicate:
                type: simple
                expression: "${exchangeProperty.placeholders[preprocessHeaders]} != null && ${exchangeProperty.placeholders[preprocessHeaders]} != 'NOT_SET' && ${exchangeProperty.placeholders[preprocessHeaders]} is 'java.util.List' && ${exchangeProperty.placeholders[preprocessHeaders].size()} > 0"
              steps:
                - method: loop
                  expression:
                    type: simple
                    expression: "${exchangeProperty.placeholders[preprocessHeaders].size()}"
                  copy: false
                  steps:
                    - method: choice
                      when:
                        - predicate:
                            type: simple
                            expression: "${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex}).getOrDefault(expression, NOT_SET)} != 'NOT_SET'"
                          steps:
                            - method: setProperty
                              key: preprocessHeaderExpression
                              value:
                                type: "simple"
                                expression: "${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex})[expression]}"
                            - method: choice
                              when:
                                - predicate:
                                    type: simple
                                    expression: "${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex}).getOrDefault(headers, NOT_SET)} != 'NOT_SET' && ${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex})[headers]} is 'java.util.Map'"
                                  steps:
                                    - method: choice
                                      when:
                                        - predicate:
                                            type: groovy
                                            expression: |
                                              preprocessHeaderExpression = exchange.properties.get("preprocessHeaderExpression")
                                              language = exchange.getContext().resolveLanguage("simple")
                                              predicate = language.createPredicate(preprocessHeaderExpression)
                                              return predicate.matches(exchange);
                                          steps:
                                            - method: log
                                              level: "DEBUG"
                                              message: "Preprocess header expression(${exchangeProperty.preprocessHeaderExpression}) matches!!"
                                            - method: setBody
                                              expression:
                                                type: simple
                                                expression: "${exchangeProperty.placeholders[preprocessHeaders].get(${header.Integration_HubLoopIndex})[headers]}"
                                            - method: process
                                              classname: com.interlinksoftware.integrationhub.config.step.processor.BodyToHeadersProcessor
                                      otherwise:
                                        - method: log
                                          level: "DEBUG"
                                          message: "Preprocess header expression(${exchangeProperty.preprocessHeaderExpression}) does not match"
                              otherwise:
                                - method: log
                                  level: "ERROR"
                                  message: "No headers for expression(exchangeProperty.preprocessHeaderExpression) in preprocessor definition '(${header.Integration_HubLoopIndex})'"
                      otherwise:
                        - method: log
                          level: "ERROR"
                          message: "No expression in preprocessor definition '${header.Integration_HubLoopIndex}'"
          otherwise:
            - method: log
              level: "DEBUG"
              message: "No preprocessor definitions"
        # REF-4IZ - Data decoding
        - method: choice
          when:
            # REF-BEK
            - predicate:
                type: simple
                expression: "${header.Content-Encoding} in 'gzip,application/gzip'"
              steps:
                # REF- - Debug message
                - method: log
                  level: "DEBUG"
                  message: "decoding from gzip"
                - method: unmarshal
                  type: gzip
        # REF-1CY -  Datatype decoding
        - method: choice
          when:
            # REF-0KL - Unmarshal JSON
            - predicate:
                type: simple
                expression: "${header.Content-Type} ~~ 'json'"
              steps:
                # REF- - Debug message
                - method: log
                  level: "DEBUG"
                  message: "decoding from json"
                - method: unmarshal
                  type: json
                - method: choice
                  when:
                    - predicate:
                        type: simple
                        expression: "${body.getClass().getName()} == 'java.lang.String'"
                      steps:
                        - method: log
                          level: "DEBUG"
                          message: "decoding from json string - ${body.getClass().getName()}"
                        - method: unmarshal
                          type: json
            # REF-FU6 - Unmarshal XML
            - predicate:
                type: simple
                expression: "${header.Content-Type} ~~ 'xml'"
              steps:
                # REF- - Debug message
                - method: log
                  level: "DEBUG"
                  message: "decoding from xml"
                - method: unmarshal
                  type: xml
            # REF-5JV - Unmarshal YAML
            - predicate:
                type: simple
                expression: "${header.Content-Type} ~~ 'yaml'"
              steps:
                # REF- - Debug message
                - method: log
                  level: "DEBUG"
                  message: "decoding from yaml"
                - method: unmarshal
                  type: yaml
          # REF-SCT - If datatype is unknown
          otherwise:
            - method: choice
              when:
                - predicate:
                    type: simple
                    expression: "${exchangeProperty.placeholders[logDropped]} != null && ${exchangeProperty.placeholders[logDropped]} == true"
                  steps:
                    # REF- - Debug message
                    - method: log
                      level: "DEBUG"
                      message: "datatype '${header.Content-Type}' unknown"
                    # REF- - Debug message
                    - method: log
                      level: "DEBUG"
                      message: "writing to dropped file"
                    # REF-4UJ - Write log message to file
                    - method: isslog
                      message: "parentId=${headers.parentId} | missed(${header.Content-Type}) | ${bodyAs(String)}"
                      type: dropped
                      queueSize: $[[uiMessageLimit]]
                      writeToFile: $[[logDropped]]
                      writeToDatabase: $[[logDropped]]
            # REF- - Handle allow list
            - method: choice
              when:
                - predicate:
                    type: simple
                    expression: "${exchangeProperty.placeholders[allowList]} != null && ${exchangeProperty.placeholders[allowList]} != 'NOT_SET' && ${exchangeProperty.placeholders[allowList]} is 'java.util.List' && ${exchangeProperty.placeholders[allowList].size()} > 0"
                  steps:
                    - method: loop
                      expression:
                        type: simple
                        expression: "${exchangeProperty.placeholders[allowList].size()}"
                      copy: false
                      steps:
                        - method: setProperty
                          key: allowListExpression
                          value:
                            type: "simple"
                            expression: "${exchangeProperty.placeholders[allowList].get(${header.Integration_HubLoopIndex})}"
                        - method: choice
                          when:
                            - predicate:
                                type: groovy
                                expression: |
                                  allowListExpression = exchange.properties.get("allowListExpression")
                                  language = exchange.getContext().resolveLanguage("simple")
                                  predicate = language.createPredicate(allowListExpression)
                                  return predicate.matches(exchange);
                              steps:
                                - method: log
                                  level: "DEBUG"
                                  message: "allowList expression(${exchangeProperty.allowListExpression}) matches"
                                - method: setProperty
                                  key: allowListCheck
                                  value:
                                    type: "constant"
                                    expression: true
                          otherwise:
                            - method: log
                              level: "DEBUG"
                              message: "allowList expression(${exchangeProperty.allowListExpression}) does not match"
                            - method: setProperty
                              key: allowListCheck
                              value:
                                type: groovy
                                expression: |
                                  prop = exchange.properties.getOrDefault("allowListCheck", "NOT_SET")
                                  if (prop == "NOT_SET") {
                                    return false;
                                  } else {
                                    return prop;
                                  }
              otherwise:
                - method: log
                  level: "DEBUG"
                  message: "No allowList definitions"
            - method: choice
              when:
                - predicate:
                    type: "simple"
                    expression: "${exchangeProperty.allowListCheck.toString()} =~ 'false'"
                  steps:
                    - method: log
                      level: "DEBUG"
                      message: "Message not allowed by allowList"
                    - method: isslog
                      message: "dropped | ${bodyAs(String)}"
                      type: dropped
                      writeToFile: $[[logDropped]]
                      writeToDatabase: $[[logDropped]]
                      queueSize: $[[uiMessageLimit]]
                    - method: setBody
                      expression:
                        type: simple
                        expression: '{ "status": "dropped", "requestId": "${exchangeId}"}'
                    - method: stop
            # REF- - Handle deny list
            - method: choice
              when:
                - predicate:
                    type: simple
                    expression: "${exchangeProperty.placeholders[denyList]} != null && ${exchangeProperty.placeholders[denyList]} != 'NOT_SET' && ${exchangeProperty.placeholders[denyList]} is 'java.util.List' && ${exchangeProperty.placeholders[denyList].size()} > 0"
                  steps:
                    - method: loop
                      expression:
                        type: simple
                        expression: "${exchangeProperty.placeholders[denyList].size()}"
                      copy: false
                      steps:
                        - method: setProperty
                          key: denyListExpression
                          value:
                            type: "simple"
                            expression: "${exchangeProperty.placeholders[denyList].get(${header.Integration_HubLoopIndex})}"
                        - method: choice
                          when:
                            - predicate:
                                type: groovy
                                expression: |
                                  denyListExpression = exchange.properties.get("denyListExpression")
                                  language = exchange.getContext().resolveLanguage("simple")
                                  predicate = language.createPredicate(denyListExpression)
                                  return predicate.matches(exchange);
                              steps:
                                - method: log
                                  level: "DEBUG"
                                  message: "denyList expression(${exchangeProperty.denyListExpression}) matches"
                                - method: setProperty
                                  key: denyListCheck
                                  value:
                                    type: "constant"
                                    expression: true
                          otherwise:
                            - method: log
                              level: "DEBUG"
                              message: "denyList expression(${exchangeProperty.denyListExpression}) does not match"
                            - method: setProperty
                              key: denyListCheck
                              value:
                                type: groovy
                                expression: |
                                  prop = exchange.properties.getOrDefault("denyListCheck", "NOT_SET")
                                  if (prop == "NOT_SET") {
                                    return false;
                                  } else {
                                    return prop;
                                  }
              otherwise:
                - method: log
                  level: "DEBUG"
                  message: "No denyList definitions"
            - method: choice
              when:
                - predicate:
                    type: "simple"
                    expression: "${exchangeProperty.denyListCheck.toString()} =~ 'true'"
                  steps:
                    - method: log
                      level: "DEBUG"
                      message: "Message not allowed by denyList"
                    - method: isslog
                      message: "dropped | ${bodyAs(String)}"
                      type: dropped
                      writeToFile: $[[logDropped]]
                      writeToDatabase: $[[logDropped]]
                      queueSize: $[[uiMessageLimit]]
                    - method: setBody
                      expression:
                        type: simple
                        expression: '{ "status": "dropped", "requestId": "${exchangeId}"}'
                    - method: stop
            # REF-IS2 - If the message matches a template key
            - method: choice
              when:
                - predicate:
                    type: simple
                    expression: "${exchangeProperty.placeholders[filters]} != null && ${exchangeProperty.placeholders[filters]} != 'NOT_SET' && ${exchangeProperty.placeholders[filters]} is 'java.util.List' && ${exchangeProperty.placeholders[filters].size()} > 0"
                  steps:
                    - method: setProperty
                      key: continueFilterLoop
                      value:
                        type: constant
                        expression: true
                    - method: setProperty
                      key: filterListSize
                      value:
                        type: simple
                        expression: "${exchangeProperty.placeholders[filters].size()}"
                    - method: doWhile
                      predicate:
                        type: simple
                        expression: "${exchangeProperty.continueFilterLoop}"
                      copy: false
                      steps:
                        - method: choice
                          when:
                            - predicate:
                                type: groovy
                                expression: |
                                  def loopIndex = exchange.properties.get('filterLoopIndex', "0") as int;
                                  def filterListSize = exchange.properties.get('filterListSize');
                                  if (loopIndex >= filterListSize) {
                                    // Exit from loop
                                    exchange.properties.put("continueFilterLoop", false)
                                    return false
                                  }

                                  def filters = exchange.properties.get('placeholders').get('filters')
                                  def filterExpression = filters[loopIndex].get('expression')

                                  exchange.properties.put("filterExpression", filterExpression)

                                  filterExpression = exchange.properties.get("filterExpression")
                                  language = exchange.getContext().resolveLanguage("simple")
                                  predicate = language.createPredicate(filterExpression)
                                  result = predicate.matches(exchange);
                                  exchange.properties.put("continueFilterLoop", !result)
                                  return result
                              steps:
                                - method: log
                                  level: "DEBUG"
                                  message: "filters expression(${exchangeProperty.filterExpression}) matches"
                                - method: setProperty
                                  key: filterCheck
                                  value:
                                    type: "constant"
                                    expression: true
                                - method: setProperty
                                  key: filterFormat
                                  value:
                                    type: "simple"
                                    expression: "${exchangeProperty.placeholders[filters].get(${exchangeProperty.filterLoopIndex}).getOrDefault('format', 'NOT_SET')}"
                                - method: choice
                                  when:
                                    - predicate:
                                        type: "simple"
                                        expression: "${exchangeProperty.filterFormat.toString()} == 'NOT_SET'"
                                      steps:
                                        - method: setProperty
                                          key: filterFormat
                                          value:
                                            type: "constant"
                                            expression: "${auto}"
                                - method: setProperty
                                  key: filterSplitType
                                  value:
                                    type: "simple"
                                    expression: "${exchangeProperty.placeholders[filters].get(${exchangeProperty.filterLoopIndex}).getOrDefault('splitType', 'NOT_SET')}"
                                - method: setProperty
                                  key: filterSplit
                                  value:
                                    type: "simple"
                                    expression: "${exchangeProperty.placeholders[filters].get(${exchangeProperty.filterLoopIndex}).getOrDefault('split', 'NOT_SET')}"
                                - method: choice
                                  when:
                                    - predicate:
                                        type: "simple"
                                        expression: "${exchangeProperty.filterSplit.toString()} == 'NOT_SET'"
                                      steps:
                                        - method: setProperty
                                          key: filterSplit
                                          value:
                                            type: "constant"
                                            expression: "${body}"
                                - method: setProperty
                                  key: filterStringifedJsonFields
                                  value:
                                    type: "simple"
                                    expression: "${exchangeProperty.placeholders[filters].get(${exchangeProperty.filterLoopIndex}).getOrDefault('stringifedJsonFields', 'NOT_SET')}"
                          otherwise:
                            - method: log
                              level: "DEBUG"
                              message: "filters expression(${exchangeProperty.filterExpression}) does not match"
                            - method: setProperty
                              key: filterCheck
                              value:
                                type: groovy
                                expression: |
                                  prop = exchange.properties.getOrDefault("filterCheck", "NOT_SET")
                                  if (prop == "NOT_SET") {
                                    return false;
                                  } else {
                                    return prop;
                                  }
                            - method: setProperty
                              key: filterLoopIndex
                              value:
                                type: "groovy"
                                expression: |
                                  def loopIndex = exchange.properties.get('filterLoopIndex') as int;
                                  return loopIndex + 1
              otherwise:
                - method: log
                  level: "DEBUG"
                  message: "No filters definitions"
                - method: setProperty
                  key: filterCheck
                  value:
                    type: "constant"
                    expression: false
        - method: choice
          when:
            - predicate:
                type: "simple"
                expression: "${exchangeProperty.filterCheck.toString()} =~ 'false'"
              steps:
                - method: setProperty
                  key: filterFormat
                  value:
                    type: "constant"
                    expression: "${auto}"
                - method: setProperty
                  key: filterExpression
                  value:
                    type: "constant"
                    expression: "DEFAULT"
                - method: setProperty
                  key: filterSplit
                  value:
                    type: "constant"
                    expression: "${body}"
        # REF- - Debug message
        - method: log
          level: "DEBUG"
          message: "body '${body}' has matched template statement '${exchangeProperty.filterExpression}'"
        # REF-8R9 - Set property "internalMatchFound" to true
        - method: setProperty
          key: internalMatchFound
          value:
            type: "constant"
            expression: true
        # Handle nested stringified json
        - method: choice
          when:
            - predicate:
                type: groovy
                expression: |
                  prop = exchange.properties.getOrDefault("filterStringifedJsonFields", "NOT_SET")
                  if (prop == "NOT_SET") {
                    return false;
                  } else {
                    return true;
                  }
              steps:
                - method: setProperty
                  key: internalUnmarshalledMsg
                  value:
                    type: "simple"
                    expression: "${body}"
                - method: loop
                  expression:
                    type: simple
                    expression: "${exchangeProperty.filterStringifedJsonFields.size()}"
                  copy: true
                  steps:
                    - method: setProperty
                      key: filterStringifiedJsonIndex
                      value:
                        type: "simple"
                        expression: "${header.Integration_HubLoopIndex}"
                    - method: setBody
                      expression:
                        type: groovy
                        expression: |
                          field = exchange.properties.filterStringifedJsonFields.get(exchange.properties.filterStringifiedJsonIndex.toString())
                          return body.get(field)
                    - method: unmarshal
                      type: json
                    - method: setBody
                      expression:
                        type: groovy
                        expression: |
                          internalUnmarshalledMsg = exchange.properties.internalUnmarshalledMsg
                          field = exchange.properties.filterStringifedJsonFields.get(exchange.properties.filterStringifiedJsonIndex.toString())

                          internalUnmarshalledMsg.put(field.toString(), body)
                          return internalUnmarshalledMsg
        - method: choice
          when:
            - predicate:
                type: simple
                expression: "${exchangeProperty.filterSplitType} =~ 'tokenize'"
              steps:
                # REF- - Debug message
                - method: log
                  level: "DEBUG"
                  message: "splitting body using (tokenize) with token: '${exchangeProperty.filterSplit}'"
                - method: convertBodyTo
                  type: String
                - method: split
                  resolve-maps-as-key-value: false
                  aggregation-strategy:
                    type: collect-to-property
                  expressions:
                    - type: groovy
                      expression: |
                        filterSplitExpression = exchange.properties.get("filterSplit")
                        language = exchange.getContext().resolveLanguage("simple")
                        expression = language.createExpression(filterSplitExpression)
                        token = expression.evaluate(exchange)
                        return body.tokenize(token);
                  steps:
                    # REF- - Store split message as "internalSplitMsg" header
                    - method: setProperty
                      key: internalSplitMsg
                      value:
                        type: "simple"
                        expression: "${body}"
                    # REF- - Set Body to contents of property "internalSplitMsg"
                    - method: setBody
                      expression:
                        type: simple
                        expression: "${exchange.properties[internalSplitMsg]}"
                    # REF- - Restore original headers
                    - method: process
                      classname: com.interlinksoftware.integrationhub.config.step.processor.RestoreOriginHeadersProcessor
                    # REF- - Cleanse headers
                    - method: process
                      classname: com.interlinksoftware.integrationhub.config.step.processor.CleanseHeadersProcessor
                    # REF- - Store exchangeId as CorrelationId
                    - method: setHeader
                      key: correlationId
                      value:
                        type: simple
                        expression: "${exchangeId}"
                    - method: convertBodyTo
                      type: java.lang.String
                    # REF-QDZ - Set header "Integration_HubFreemarkerTemplate" to the matched template
                    - method: setHeader
                      key: Integration_HubFreemarkerTemplate
                      value:
                        type: "constant"
                        expression: |
                          <@compress single_line=true>
                            <#assign placeholder = "$[[blankPlaceholder]]">
                            <#assign newline_placeholder = "$[[newlinePlaceholder]]">

                            <#function sanitize sdata='null'>
                                <#if sdata?length != 0>
                                  <#if sdata?is_number>
                                    <#return sdata?string.computer>
                                  <#elseif sdata?is_string>
                                    <#return sdata?replace('(\\r\\n)+|\\r+|\\n', newline_placeholder, 'r')>
                                  </#if>
                                <#else>
                                    <#return "${placeholder}">
                                </#if>
                            </#function>
                            "${sanitize(body)}"
                          </@compress>
                    - method: setHeader
                      key: Integration_HubFreemarkerTemplate
                      value:
                        type: "simple"
                        expression: "${headers.Integration_HubFreemarkerTemplate}"
                    # REF-4A1 - Compile FTL template
                    - method: to
                      component: freemarker
                      properties:
                        resourceUri: dummy
                        allowTemplateFromHeader: true
                        allowContextMapAll: true
                    # Remove duplicate '|' characters from the body if any
                    - method: setProperty
                      key: bodyWithRemovedDuplicates
                      value:
                        type: groovy
                        expression: |
                          return body.replace('| |', '|')
                    # REF-OHH - Set property "internalProcessedMessage" to bodyWithRemovedDuplicates
                    - method: setProperty
                      key: internalProcessedMessage
                      value:
                        type: "simple"
                        expression: "${exchange.properties.getOrDefault('bodyWithRemovedDuplicates')}"
                    # REF-3P0 - If logProcessed is enabled
                    - method: choice
                      when:
                        - predicate:
                            type: simple
                            expression: "${exchangeProperty.placeholders[logProcessed]} != null && ${exchangeProperty.placeholders[logProcessed]} == true"
                          steps:
                            # REF- - Debug message
                            - method: log
                              level: "DEBUG"
                              message: "writing to proccessed file"
                            # REF-4MH - Log message to file
                            - method: isslog
                              message: "parentId=${headers.parentId} | processed(${exchange.properties['filterExpression']}) | ${bodyAs(String)}"
                              type: processed
                              queueSize: $[[uiMessageLimit]]
                              writeToFile: $[[logProcessed]]
                              writeToDatabase: $[[logProcessed]]
                    # REF-6CU - Loop over each BES host
                    - method: split
                      resolve-maps-as-key-value: false
                      expressions:
                        - type: simple
                          expression: "${exchangeProperty.placeholders[destinationServers]}"
                      steps:
                        # REF-JC9 - Set property "destinationHost" to the destination host and port
                        - method: setProperty
                          key: destinationHost
                          value:
                            type: "simple"
                            expression: "${body[hostname]}:${body[port]}"
                        # REF- - Debug message
                        - method: log
                          level: "DEBUG"
                          message: "sending body to ${exchangeProperty.destinationHost}"
                        # REF-AGS - Set body to the processed message
                        - method: setBody
                          expression:
                            type: simple
                            expression: "${exchange.properties[internalProcessedMessage]}"
                        # # REF-OE1 - Send payload to socket
                        - method: dynamic-to
                          expression: "netty:tcp://${exchange.properties[destinationHost]}?clientMode=true&sync=false&textline=true"
                        # REF-AGM - If log received is enabled
                        - method: choice
                          when:
                            - predicate:
                                type: simple
                                expression: "${exchangeProperty.placeholders[logSuccess]} != null && ${exchangeProperty.placeholders[logSuccess]} == true"
                              steps:
                                # REF- - Debug message
                                - method: log
                                  level: "DEBUG"
                                  message: "writing to the success file"
                                - method: setBody
                                  expression:
                                    type: simple
                                    expression: "${exchange.properties[internalProcessedMessage]}"
                                - method: isslog
                                  message: "parentId=${headers.parentId} | success | ${bodyAs(String)}"
                                  type: success
                                  queueSize: $[[uiMessageLimit]]
                                  writeToFile: $[[logSuccess]]
                                  writeToDatabase: $[[logSuccess]]
                    # REF- - Restore headers from exchange
                    - method: process
                      classname: com.interlinksoftware.integrationhub.config.step.processor.RestoreOriginHeadersProcessor
          otherwise:
            # REF-SLB - Split payload if array
            - method: log
              level: "DEBUG"
              message: "splitting body using '${exchangeProperty.filterSplit}'"
            - method: split
              resolve-maps-as-key-value: false
              aggregation-strategy:
                type: collect-to-property
              expressions:
                - type: groovy
                  expression: |
                    filterSplitExpression = exchange.properties.get("filterSplit")
                    language = exchange.getContext().resolveLanguage("simple")
                    expression = language.createExpression(filterSplitExpression)
                    return expression.evaluate(exchange);
              steps:
                # REF- - Store split message as "internalSplitMsg" header
                - method: setProperty
                  key: internalSplitMsg
                  value:
                    type: "simple"
                    expression: "${body}"
                # REF- - Set Body to contents of property "internalSplitMsg"
                - method: setBody
                  expression:
                    type: simple
                    expression: "${exchange.properties[internalSplitMsg]}"
                # REF- - Restore original headers
                - method: process
                  classname: com.interlinksoftware.integrationhub.config.step.processor.RestoreOriginHeadersProcessor
                # REF- - Cleanse headers
                - method: process
                  classname: com.interlinksoftware.integrationhub.config.step.processor.CleanseHeadersProcessor
                # REF- - Store exchangeId as CorrelationId
                - method: setHeader
                  key: correlationId
                  value:
                    type: simple
                    expression: "${exchangeId}"
                - method: convertBodyTo
                  type: java.lang.String
                # REF-QDZ - Set header "Integration_HubFreemarkerTemplate" to the matched template
                - method: setHeader
                  key: Integration_HubFreemarkerTemplate
                  value:
                    type: "constant"
                    expression: |
                      <@compress single_line=true>
                        <#assign placeholder = "$[[blankPlaceholder]]">
                        <#assign newline_placeholder = "$[[newlinePlaceholder]]">

                        <#function sanitize sdata='null'>
                            <#if sdata?length != 0>
                              <#if sdata?is_number>
                                <#return sdata?string.computer>
                              <#elseif sdata?is_string>
                                <#return sdata?replace('(\\r\\n)+|\\r+|\\n', newline_placeholder, 'r')>
                              </#if>
                            <#else>
                                <#return "${placeholder}">
                            </#if>
                        </#function>
                        "${sanitize(body)}"
                      </@compress>
                - method: setHeader
                  key: Integration_HubFreemarkerTemplate
                  value:
                    type: "simple"
                    expression: "${headers.Integration_HubFreemarkerTemplate}"
                # REF-4A1 - Compile FTL template
                - method: to
                  component: freemarker
                  properties:
                    resourceUri: dummy
                    allowTemplateFromHeader: true
                    allowContextMapAll: true
                # Remove duplicate '|' characters from the body if any
                - method: setProperty
                  key: bodyWithRemovedDuplicates
                  value:
                    type: groovy
                    expression: |
                      return body.replace('| |', '|')
                # REF-OHH - Set property "internalProcessedMessage" to bodyWithRemovedDuplicates
                - method: setProperty
                  key: internalProcessedMessage
                  value:
                    type: "simple"
                    expression: "${exchange.properties.getOrDefault('bodyWithRemovedDuplicates')}"
                # REF-3P0 - If logProcessed is enabled
                - method: choice
                  when:
                    - predicate:
                        type: simple
                        expression: "${exchangeProperty.placeholders[logProcessed]} != null && ${exchangeProperty.placeholders[logProcessed]} == true"
                      steps:
                        # REF- - Debug message
                        - method: log
                          level: "DEBUG"
                          message: "writing to proccessed file"
                        # REF-4MH - Log message to file
                        - method: isslog
                          message: "parentId=${headers.parentId} | processed(${exchange.properties['filterExpression']}) | ${bodyAs(String)}"
                          type: processed
                          queueSize: $[[uiMessageLimit]]
                          writeToFile: $[[logProcessed]]
                          writeToDatabase: $[[logProcessed]]
                # REF-6CU - Loop over each BES host
                - method: split
                  resolve-maps-as-key-value: false
                  expressions:
                    - type: simple
                      expression: "${exchangeProperty.placeholders[destinationServers]}"
                  steps:
                    # REF-JC9 - Set property "destinationHost" to the destination host and port
                    - method: setProperty
                      key: destinationHost
                      value:
                        type: "simple"
                        expression: "${body[hostname]}:${body[port]}"
                    # REF- - Debug message
                    - method: log
                      level: "DEBUG"
                      message: "sending body to ${exchangeProperty.destinationHost}"
                    # REF-AGS - Set body to the processed message
                    - method: setBody
                      expression:
                        type: simple
                        expression: "${exchange.properties[internalProcessedMessage]}"
                    # # REF-OE1 - Send payload to socket
                    - method: dynamic-to
                      expression: "netty:tcp://${exchange.properties[destinationHost]}?clientMode=true&sync=false&textline=true"
                    # REF-AGM - If log received is enabled
                    - method: choice
                      when:
                        - predicate:
                            type: simple
                            expression: "${exchangeProperty.placeholders[logSuccess]} != null && ${exchangeProperty.placeholders[logSuccess]} == true"
                          steps:
                            # REF- - Debug message
                            - method: log
                              level: "DEBUG"
                              message: "writing to the success file"
                            - method: setBody
                              expression:
                                type: simple
                                expression: "${exchange.properties[internalProcessedMessage]}"
                            - method: isslog
                              message: "parentId=${headers.parentId} | success | ${bodyAs(String)}"
                              type: success
                              queueSize: $[[uiMessageLimit]]
                              writeToFile: $[[logSuccess]]
                              writeToDatabase: $[[logSuccess]]
                # REF- - Restore headers from exchange
                - method: process
                  classname: com.interlinksoftware.integrationhub.config.step.processor.RestoreOriginHeadersProcessor
        - method: setBody
          expression:
            type: simple
            expression: "{\"status\": \"OK\", \"requestId\": \"${headers.parentId}\"}"
        # REF- - Set content type header
        - method: setHeader
          key: Content-Type
          value:
            type: constant
            expression: application/json